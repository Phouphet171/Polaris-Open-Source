; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\hook.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0P@DGIDOA@GetProcAddress?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08PNLNEKOB@kernel32?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HECBOJPO@LoadLibraryExW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GILJFMCJ@LoadLibraryExA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@KCFDJLIF@LoadLibraryW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?HookAddHook@@YAXPBD0PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookGetOriginal@@YAPAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WritePointer@@YAHPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookFunction@@YAHPAUHINSTANCE__@@PAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookGetProcAddress@@YGP6GHXZPAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookAddGetProcAddressHook@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookModule@@YAXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ComparePointers@@YAHPBX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookAllLoadedModules@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookLoadLibraryExW@@YGPAUHINSTANCE__@@PBGPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookLoadLibraryExA@@YGPAUHINSTANCE__@@PBDPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookLoadLibraryW@@YGPAUHINSTANCE__@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookLoadLibraryA@@YGPAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HookAllLoadedAndFutureModules@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?nhooked@?1??HookAllLoadedModules@@YAXXZ@4HA DD 01H DUP (?) ; `HookAllLoadedModules'::`2'::nhooked
_nhooks	DD	01H DUP (?)
_capacity DD	01H DUP (?)
_hooktable DD	01H DUP (?)
_BSS	ENDS
PUBLIC	?HookAddHook@@YAXPBD0PAX@Z			; HookAddHook
EXTRN	__imp__GetProcAddress@8:NEAR
EXTRN	__imp__HeapAlloc@12:NEAR
EXTRN	__imp__HeapReAlloc@16:NEAR
EXTRN	__imp__GetProcessHeap@0:NEAR
EXTRN	__imp__LoadLibraryA@4:NEAR
EXTRN	_strcpy:NEAR
; Function compile flags: /Odt /ZI
; File c:\documents and settings\marcstgr\my documents\visual studio projects\beta\src\pethooks\hook.cpp
;	COMDAT ?HookAddHook@@YAXPBD0PAX@Z
_TEXT	SEGMENT
_dllname$ = 8						; size = 4
_funcname$ = 12						; size = 4
_func$ = 16						; size = 4
?HookAddHook@@YAXPBD0PAX@Z PROC NEAR			; HookAddHook, COMDAT

; 23   : void HookAddHook(const char* dllname, const char* funcname, void* func) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 24   : 	if (!hooktable) {

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hooktable, 0
  00010	75 2a		 jne	 SHORT $L26611

; 25   : 		capacity = 64;

  00012	c7 05 00 00 00
	00 40 00 00 00	 mov	 DWORD PTR _capacity, 64	; 00000040H

; 26   : 		hooktable = (HOOKENTRY*) HeapAlloc(
; 27   : 			GetProcessHeap(), 0, capacity*sizeof(HOOKENTRY));

  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR _capacity
  00021	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00027	50		 push	 eax
  00028	6a 00		 push	 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapAlloc@12
  00037	a3 00 00 00 00	 mov	 DWORD PTR _hooktable, eax
$L26611:

; 28   : 	}
; 29   : 	if (nhooks == capacity) {

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR _nhooks
  00041	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _capacity
  00047	75 33		 jne	 SHORT $L26614

; 30   : 		capacity *= 2;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR _capacity
  0004e	d1 e0		 shl	 eax, 1
  00050	a3 00 00 00 00	 mov	 DWORD PTR _capacity, eax

; 31   : 		hooktable = (HOOKENTRY*) HeapReAlloc(
; 32   : 			GetProcessHeap(), 0, hooktable, capacity*sizeof(HOOKENTRY));

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR _capacity
  0005a	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00060	50		 push	 eax
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hooktable
  00067	51		 push	 ecx
  00068	6a 00		 push	 0
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcessHeap@0
  00070	50		 push	 eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__HeapReAlloc@16
  00077	a3 00 00 00 00	 mov	 DWORD PTR _hooktable, eax
$L26614:

; 33   : 	}
; 34   : 	strcpy(hooktable[nhooks].dllname, dllname);

  0007c	8b 45 08	 mov	 eax, DWORD PTR _dllname$[ebp]
  0007f	50		 push	 eax
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nhooks
  00086	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  0008c	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR _hooktable
  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 _strcpy
  00098	83 c4 08	 add	 esp, 8

; 35   : 	strcpy(hooktable[nhooks].funcname, funcname);

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _funcname$[ebp]
  0009e	50		 push	 eax
  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _nhooks
  000a5	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  000ab	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hooktable
  000b1	8d 84 0a 04 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+260]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _strcpy
  000be	83 c4 08	 add	 esp, 8

; 36   : 	hooktable[nhooks].oldfunc = GetProcAddress(LoadLibraryA(dllname), funcname);

  000c1	8b 45 0c	 mov	 eax, DWORD PTR _funcname$[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _dllname$[ebp]
  000c8	51		 push	 ecx
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000cf	50		 push	 eax
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000d6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _nhooks
  000dc	69 d2 10 02 00
	00		 imul	 edx, 528		; 00000210H
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hooktable
  000e8	89 84 11 08 02
	00 00		 mov	 DWORD PTR [ecx+edx+520], eax

; 37   : 	hooktable[nhooks].newfunc = func;

  000ef	a1 00 00 00 00	 mov	 eax, DWORD PTR _nhooks
  000f4	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hooktable
  00100	8b 55 10	 mov	 edx, DWORD PTR _func$[ebp]
  00103	89 94 01 0c 02
	00 00		 mov	 DWORD PTR [ecx+eax+524], edx

; 38   : 	nhooks++;

  0010a	a1 00 00 00 00	 mov	 eax, DWORD PTR _nhooks
  0010f	83 c0 01	 add	 eax, 1
  00112	a3 00 00 00 00	 mov	 DWORD PTR _nhooks, eax

; 39   : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
?HookAddHook@@YAXPBD0PAX@Z ENDP				; HookAddHook
_TEXT	ENDS
PUBLIC	?HookGetOriginal@@YAPAXPBD@Z			; HookGetOriginal
EXTRN	_strcmp:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?HookGetOriginal@@YAPAXPBD@Z
_TEXT	SEGMENT
_i$26620 = -4						; size = 4
_funcname$ = 8						; size = 4
?HookGetOriginal@@YAPAXPBD@Z PROC NEAR			; HookGetOriginal, COMDAT

; 42   : void* HookGetOriginal(const char* funcname) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 43   : 	for (int i = 0; i < nhooks; i++) {

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$26620[ebp], 0
  00010	eb 09		 jmp	 SHORT $L26621
$L26622:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$26620[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$26620[ebp], eax
$L26621:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$26620[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nhooks
  00024	7d 41		 jge	 SHORT $L26623

; 44   : 		if (strcmp(hooktable[i].funcname, funcname) == 0) {

  00026	8b 45 08	 mov	 eax, DWORD PTR _funcname$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _i$26620[ebp]
  0002d	69 c9 10 02 00
	00		 imul	 ecx, 528		; 00000210H
  00033	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _hooktable
  00039	8d 84 0a 04 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+260]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _strcmp
  00046	83 c4 08	 add	 esp, 8
  00049	85 c0		 test	 eax, eax
  0004b	75 18		 jne	 SHORT $L26624

; 45   : 			return hooktable[i].oldfunc;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _i$26620[ebp]
  00050	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hooktable
  0005c	8b 84 01 08 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax+520]
  00063	eb 04		 jmp	 SHORT $L26619
$L26624:

; 46   : 		}
; 47   : 	}

  00065	eb ab		 jmp	 SHORT $L26622
$L26623:

; 48   : 	return NULL;

  00067	33 c0		 xor	 eax, eax
$L26619:

; 49   : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
?HookGetOriginal@@YAPAXPBD@Z ENDP			; HookGetOriginal
_TEXT	ENDS
PUBLIC	?HookGetProcAddress@@YGP6GHXZPAUHINSTANCE__@@PBD@Z ; HookGetProcAddress
PUBLIC	??_C@_0P@DGIDOA@GetProcAddress?$AA@		; `string'
;	COMDAT ??_C@_0P@DGIDOA@GetProcAddress?$AA@
CONST	SEGMENT
??_C@_0P@DGIDOA@GetProcAddress?$AA@ DB 'GetProcAddress', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?HookGetProcAddress@@YGP6GHXZPAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT
_i$26686 = -8						; size = 4
_addr$ = -4						; size = 4
_module$ = 8						; size = 4
_funcname$ = 12						; size = 4
?HookGetProcAddress@@YGP6GHXZPAUHINSTANCE__@@PBD@Z PROC NEAR ; HookGetProcAddress, COMDAT

; 115  : FARPROC WINAPI HookGetProcAddress(HMODULE module, LPCSTR funcname) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 116  : 	FARPROC addr = ORIGINAL(GetProcAddress)(module, funcname);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _funcname$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _module$[ebp]
  00010	51		 push	 ecx
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@DGIDOA@GetProcAddress?$AA@
  00016	e8 00 00 00 00	 call	 ?HookGetOriginal@@YAPAXPBD@Z ; HookGetOriginal
  0001b	83 c4 04	 add	 esp, 4
  0001e	ff d0		 call	 eax
  00020	89 45 fc	 mov	 DWORD PTR _addr$[ebp], eax

; 117  : 	for (int i = 0; i < nhooks; i++) {

  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$26686[ebp], 0
  0002a	eb 09		 jmp	 SHORT $L26687
$L26688:
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _i$26686[ebp]
  0002f	83 c0 01	 add	 eax, 1
  00032	89 45 f8	 mov	 DWORD PTR _i$26686[ebp], eax
$L26687:
  00035	8b 45 f8	 mov	 eax, DWORD PTR _i$26686[ebp]
  00038	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nhooks
  0003e	7d 35		 jge	 SHORT $L26689

; 118  :         if (addr == hooktable[i].oldfunc) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _i$26686[ebp]
  00043	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hooktable
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _addr$[ebp]
  00052	3b 94 01 08 02
	00 00		 cmp	 edx, DWORD PTR [ecx+eax+520]
  00059	75 18		 jne	 SHORT $L26690

; 119  :             return (FARPROC) hooktable[i].newfunc;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _i$26686[ebp]
  0005e	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hooktable
  0006a	8b 84 01 0c 02
	00 00		 mov	 eax, DWORD PTR [ecx+eax+524]
  00071	eb 05		 jmp	 SHORT $L26682
$L26690:

; 120  :         }
; 121  : 	}

  00073	eb b7		 jmp	 SHORT $L26688
$L26689:

; 122  : 	return addr;

  00075	8b 45 fc	 mov	 eax, DWORD PTR _addr$[ebp]
$L26682:

; 123  : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
?HookGetProcAddress@@YGP6GHXZPAUHINSTANCE__@@PBD@Z ENDP	; HookGetProcAddress
_TEXT	ENDS
PUBLIC	??_C@_08PNLNEKOB@kernel32?$AA@			; `string'
PUBLIC	?HookAddGetProcAddressHook@@YAXXZ		; HookAddGetProcAddressHook
;	COMDAT ??_C@_08PNLNEKOB@kernel32?$AA@
CONST	SEGMENT
??_C@_08PNLNEKOB@kernel32?$AA@ DB 'kernel32', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?HookAddGetProcAddressHook@@YAXXZ
_TEXT	SEGMENT
?HookAddGetProcAddressHook@@YAXXZ PROC NEAR		; HookAddGetProcAddressHook, COMDAT

; 126  : void HookAddGetProcAddressHook() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 127  : 	HookAddHook("kernel32", "GetProcAddress", HookGetProcAddress);

  00009	68 00 00 00 00	 push	 OFFSET FLAT:?HookGetProcAddress@@YGP6GHXZPAUHINSTANCE__@@PBD@Z ; HookGetProcAddress
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@DGIDOA@GetProcAddress?$AA@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08PNLNEKOB@kernel32?$AA@
  00018	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 128  : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?HookAddGetProcAddressHook@@YAXXZ ENDP			; HookAddGetProcAddressHook
_TEXT	ENDS
PUBLIC	?HookModule@@YAXPAUHINSTANCE__@@@Z		; HookModule
; Function compile flags: /Odt /ZI
;	COMDAT ?HookModule@@YAXPAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$26698 = -4						; size = 4
_module$ = 8						; size = 4
?HookModule@@YAXPAUHINSTANCE__@@@Z PROC NEAR		; HookModule, COMDAT

; 131  : void HookModule(HMODULE module) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 132  : 	for (int i = 0; i < nhooks; i++) {

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$26698[ebp], 0
  00010	eb 09		 jmp	 SHORT $L26699
$L26700:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$26698[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$26698[ebp], eax
$L26699:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$26698[ebp]
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _nhooks
  00024	7d 3c		 jge	 SHORT $L26697

; 133  :         HookFunction(module, hooktable[i].oldfunc, hooktable[i].newfunc);

  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$26698[ebp]
  00029	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hooktable
  00035	8b 94 01 0c 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+524]
  0003c	52		 push	 edx
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _i$26698[ebp]
  00040	69 c0 10 02 00
	00		 imul	 eax, 528		; 00000210H
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _hooktable
  0004c	8b 94 01 08 02
	00 00		 mov	 edx, DWORD PTR [ecx+eax+520]
  00053	52		 push	 edx
  00054	8b 45 08	 mov	 eax, DWORD PTR _module$[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?HookFunction@@YAHPAUHINSTANCE__@@PAX1@Z ; HookFunction
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 134  : 	}

  00060	eb b0		 jmp	 SHORT $L26700
$L26697:

; 135  : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?HookModule@@YAXPAUHINSTANCE__@@@Z ENDP			; HookModule
_TEXT	ENDS
EXTRN	__imp__IsBadReadPtr@8:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?HookFunction@@YAHPAUHINSTANCE__@@PAX1@Z
_TEXT	SEGMENT
_funcptr$26676 = -36					; size = 4
_thunk$26669 = -32					; size = 4
_name$26665 = -28					; size = 4
_success$ = -24						; size = 4
_importdesc$ = -20					; size = 4
_offset$ = -16						; size = 4
_directory$ = -12					; size = 4
_ntheader$ = -8						; size = 4
_dosheader$ = -4					; size = 4
_module$ = 8						; size = 4
_oldfunc$ = 12						; size = 4
_newfunc$ = 16						; size = 4
?HookFunction@@YAHPAUHINSTANCE__@@PAX1@Z PROC NEAR	; HookFunction, COMDAT

; 79   : static BOOL HookFunction(HMODULE module, void* oldfunc, void* newfunc) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 80   : 	// Make sure we can read the module header.
; 81   : 	if (IsBadReadPtr(module, sizeof(PIMAGE_NT_HEADERS))) return FALSE;

  00009	6a 04		 push	 4
  0000b	8b 45 08	 mov	 eax, DWORD PTR _module$[ebp]
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadReadPtr@8
  00015	85 c0		 test	 eax, eax
  00017	74 07		 je	 SHORT $L26642
  00019	33 c0		 xor	 eax, eax
  0001b	e9 d3 00 00 00	 jmp	 $L26640
$L26642:

; 82   : 
; 83   : 	// Navigate to the module's import table.
; 84   : 	GETPOINTER(IMAGE_DOS_HEADER, dosheader, module, 0);

  00020	8b 45 08	 mov	 eax, DWORD PTR _module$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _dosheader$[ebp], eax

; 85   : 	if (dosheader->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _dosheader$[ebp]
  00029	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0002c	81 f9 4d 5a 00
	00		 cmp	 ecx, 23117		; 00005a4dH
  00032	74 07		 je	 SHORT $L26647
  00034	33 c0		 xor	 eax, eax
  00036	e9 b8 00 00 00	 jmp	 $L26640
$L26647:

; 86   : 
; 87   : 	GETPOINTER(IMAGE_NT_HEADERS, ntheader, module, dosheader->e_lfanew);

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _dosheader$[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _module$[ebp]
  00041	03 48 3c	 add	 ecx, DWORD PTR [eax+60]
  00044	89 4d f8	 mov	 DWORD PTR _ntheader$[ebp], ecx

; 88   : 	if (ntheader->Signature != IMAGE_NT_SIGNATURE) return FALSE;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _ntheader$[ebp]
  0004a	81 38 50 45 00
	00		 cmp	 DWORD PTR [eax], 17744	; 00004550H
  00050	74 07		 je	 SHORT $L26652
  00052	33 c0		 xor	 eax, eax
  00054	e9 9a 00 00 00	 jmp	 $L26640
$L26652:

; 89   : 
; 90   : 	IMAGE_DATA_DIRECTORY* directory = ntheader->OptionalHeader.DataDirectory;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _ntheader$[ebp]
  0005c	83 c0 78	 add	 eax, 120		; 00000078H
  0005f	89 45 f4	 mov	 DWORD PTR _directory$[ebp], eax

; 91   : 	DWORD offset = directory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

  00062	8b 45 f4	 mov	 eax, DWORD PTR _directory$[ebp]
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	89 4d f0	 mov	 DWORD PTR _offset$[ebp], ecx

; 92   : 	GETPOINTER(IMAGE_IMPORT_DESCRIPTOR, importdesc, module, offset);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _module$[ebp]
  0006e	03 45 f0	 add	 eax, DWORD PTR _offset$[ebp]
  00071	89 45 ec	 mov	 DWORD PTR _importdesc$[ebp], eax

; 93   : 	if (importdesc == (IMAGE_IMPORT_DESCRIPTOR*) ntheader) return FALSE;

  00074	8b 45 ec	 mov	 eax, DWORD PTR _importdesc$[ebp]
  00077	3b 45 f8	 cmp	 eax, DWORD PTR _ntheader$[ebp]
  0007a	75 04		 jne	 SHORT $L26660
  0007c	33 c0		 xor	 eax, eax
  0007e	eb 73		 jmp	 SHORT $L26640
$L26660:

; 94   : 
; 95   : 	// Scan the import table and replace all occurrences of the given function pointer.
; 96   : 	// The table contains a list of import descriptors, one for each imported module,
; 97   : 	// and each descriptor points to a list of thunks, one for each imported function.
; 98   : 	BOOL success = FALSE;

  00080	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _success$[ebp], 0

; 99   : 	for (; importdesc->Name; importdesc++) {

  00087	eb 09		 jmp	 SHORT $L26662
$L26663:
  00089	8b 45 ec	 mov	 eax, DWORD PTR _importdesc$[ebp]
  0008c	83 c0 14	 add	 eax, 20			; 00000014H
  0008f	89 45 ec	 mov	 DWORD PTR _importdesc$[ebp], eax
$L26662:
  00092	8b 45 ec	 mov	 eax, DWORD PTR _importdesc$[ebp]
  00095	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00099	74 55		 je	 SHORT $L26664

; 100  : 		GETPOINTER(char, name, module, importdesc->Name);

  0009b	8b 45 ec	 mov	 eax, DWORD PTR _importdesc$[ebp]
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _module$[ebp]
  000a1	03 48 0c	 add	 ecx, DWORD PTR [eax+12]
  000a4	89 4d e4	 mov	 DWORD PTR _name$26665[ebp], ecx

; 101  : 		GETPOINTER(IMAGE_THUNK_DATA, thunk, module, importdesc->FirstThunk);

  000a7	8b 45 ec	 mov	 eax, DWORD PTR _importdesc$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _module$[ebp]
  000ad	03 48 10	 add	 ecx, DWORD PTR [eax+16]
  000b0	89 4d e0	 mov	 DWORD PTR _thunk$26669[ebp], ecx

; 102  : 		for (; thunk->u1.Function; thunk++) {

  000b3	eb 09		 jmp	 SHORT $L26673
$L26674:
  000b5	8b 45 e0	 mov	 eax, DWORD PTR _thunk$26669[ebp]
  000b8	83 c0 04	 add	 eax, 4
  000bb	89 45 e0	 mov	 DWORD PTR _thunk$26669[ebp], eax
$L26673:
  000be	8b 45 e0	 mov	 eax, DWORD PTR _thunk$26669[ebp]
  000c1	83 38 00	 cmp	 DWORD PTR [eax], 0
  000c4	74 28		 je	 SHORT $L26675

; 103  : 			void** funcptr = (void**) &thunk->u1.Function;

  000c6	8b 45 e0	 mov	 eax, DWORD PTR _thunk$26669[ebp]
  000c9	89 45 dc	 mov	 DWORD PTR _funcptr$26676[ebp], eax

; 104  : 			if (*funcptr == oldfunc) {

  000cc	8b 45 dc	 mov	 eax, DWORD PTR _funcptr$26676[ebp]
  000cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d1	3b 4d 0c	 cmp	 ecx, DWORD PTR _oldfunc$[ebp]
  000d4	75 16		 jne	 SHORT $L26678

; 105  : 				success |= WritePointer(funcptr, newfunc);

  000d6	8b 45 10	 mov	 eax, DWORD PTR _newfunc$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d dc	 mov	 ecx, DWORD PTR _funcptr$26676[ebp]
  000dd	51		 push	 ecx
  000de	e8 00 00 00 00	 call	 ?WritePointer@@YAHPAPAXPAX@Z ; WritePointer
  000e3	83 c4 08	 add	 esp, 8
  000e6	0b 45 e8	 or	 eax, DWORD PTR _success$[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR _success$[ebp], eax
$L26678:

; 106  : 			}
; 107  : 		}

  000ec	eb c7		 jmp	 SHORT $L26674
$L26675:

; 108  : 	}

  000ee	eb 99		 jmp	 SHORT $L26663
$L26664:

; 109  : 
; 110  : 	return success;

  000f0	8b 45 e8	 mov	 eax, DWORD PTR _success$[ebp]
$L26640:

; 111  : }

  000f3	5f		 pop	 edi
  000f4	5e		 pop	 esi
  000f5	5b		 pop	 ebx
  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
?HookFunction@@YAHPAUHINSTANCE__@@PAX1@Z ENDP		; HookFunction
_TEXT	ENDS
EXTRN	__imp__VirtualProtect@16:NEAR
EXTRN	__imp__IsBadWritePtr@8:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?WritePointer@@YAHPAPAXPAX@Z
_TEXT	SEGMENT
_newaccess$ = -8					; size = 4
_oldaccess$ = -4					; size = 4
_destination$ = 8					; size = 4
_value$ = 12						; size = 4
?WritePointer@@YAHPAPAXPAX@Z PROC NEAR			; WritePointer, COMDAT

; 52   : static BOOL WritePointer(void** destination, void* value) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 53   : 	// If the destination is writable, just write there.
; 54   : 	if (!IsBadWritePtr(destination, sizeof(void*))) {

  00009	6a 04		 push	 4
  0000b	8b 45 08	 mov	 eax, DWORD PTR _destination$[ebp]
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsBadWritePtr@8
  00015	85 c0		 test	 eax, eax
  00017	75 0f		 jne	 SHORT $L26630

; 55   : 		*destination = value;

  00019	8b 45 08	 mov	 eax, DWORD PTR _destination$[ebp]
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 56   : 		return TRUE;

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	eb 44		 jmp	 SHORT $L26628
$L26630:

; 57   : 	}
; 58   : 
; 59   : 	// Otherwise, try to make the destination writable, then do the write.
; 60   : 	DWORD oldaccess, newaccess = PAGE_EXECUTE_READWRITE;

  00028	c7 45 f8 40 00
	00 00		 mov	 DWORD PTR _newaccess$[ebp], 64 ; 00000040H

; 61   : 	if (VirtualProtect(destination, sizeof(void*), newaccess, &oldaccess)) {

  0002f	8d 45 fc	 lea	 eax, DWORD PTR _oldaccess$[ebp]
  00032	50		 push	 eax
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _newaccess$[ebp]
  00036	51		 push	 ecx
  00037	6a 04		 push	 4
  00039	8b 55 08	 mov	 edx, DWORD PTR _destination$[ebp]
  0003c	52		 push	 edx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualProtect@16
  00043	85 c0		 test	 eax, eax
  00045	74 23		 je	 SHORT $L26634

; 62   : 		*destination = value;

  00047	8b 45 08	 mov	 eax, DWORD PTR _destination$[ebp]
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0004d	89 08		 mov	 DWORD PTR [eax], ecx

; 63   : 		VirtualProtect(destination, sizeof(void*), oldaccess, &newaccess);

  0004f	8d 45 f8	 lea	 eax, DWORD PTR _newaccess$[ebp]
  00052	50		 push	 eax
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _oldaccess$[ebp]
  00056	51		 push	 ecx
  00057	6a 04		 push	 4
  00059	8b 55 08	 mov	 edx, DWORD PTR _destination$[ebp]
  0005c	52		 push	 edx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualProtect@16

; 64   : 		return TRUE;

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	eb 02		 jmp	 SHORT $L26628
$L26634:

; 65   : 	}
; 66   : 	return FALSE;

  0006a	33 c0		 xor	 eax, eax
$L26628:

; 67   : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?WritePointer@@YAHPAPAXPAX@Z ENDP			; WritePointer
_TEXT	ENDS
PUBLIC	?HookAllLoadedModules@@YAXXZ			; HookAllLoadedModules
EXTRN	_bsearch:NEAR
EXTRN	_qsort:NEAR
EXTRN	__imp__GetCurrentProcess@0:NEAR
EXTRN	__imp__GetModuleHandleA@4:NEAR
EXTRN	__imp__GetModuleHandleExA@12:NEAR
EXTRN	_EnumProcessModules@16:NEAR
_BSS	SEGMENT
?hooked@?1??HookAllLoadedModules@@YAXXZ@4PAPAUHINSTANCE__@@A DD 03e8H DUP (?) ; `HookAllLoadedModules'::`2'::hooked
; Function compile flags: /Odt /ZI
_BSS	ENDS
;	COMDAT ?HookAllLoadedModules@@YAXXZ
_TEXT	SEGMENT
_i$26723 = -4020					; size = 4
_thismodule$ = -4016					; size = 4
_nmodules$ = -4012					; size = 4
_length$ = -4008					; size = 4
_modules$ = -4004					; size = 4000
_process$ = -4						; size = 4
?HookAllLoadedModules@@YAXXZ PROC NEAR			; HookAllLoadedModules, COMDAT

; 142  : void HookAllLoadedModules() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 0f 00
	00		 sub	 esp, 4084		; 00000ff4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 143  : 	static HMODULE hooked[MAX_MODULES]; // sorted list of all hooked modules
; 144  : 	static int nhooked = 0;
; 145  : 
; 146  : 	// Get a list of all the modules in the current process.
; 147  : 	HANDLE process = GetCurrentProcess();

  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  00012	89 45 fc	 mov	 DWORD PTR _process$[ebp], eax

; 148  : 	HMODULE modules[MAX_MODULES];
; 149  : 	DWORD length = 0;

  00015	c7 85 58 f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _length$[ebp], 0

; 150  : 	if (!EnumProcessModules(process, modules, sizeof(modules), &length)) return;

  0001f	8d 85 58 f0 ff
	ff		 lea	 eax, DWORD PTR _length$[ebp]
  00025	50		 push	 eax
  00026	68 a0 0f 00 00	 push	 4000			; 00000fa0H
  0002b	8d 8d 5c f0 ff
	ff		 lea	 ecx, DWORD PTR _modules$[ebp]
  00031	51		 push	 ecx
  00032	8b 55 fc	 mov	 edx, DWORD PTR _process$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 _EnumProcessModules@16
  0003b	85 c0		 test	 eax, eax
  0003d	75 05		 jne	 SHORT $L26717
  0003f	e9 1e 01 00 00	 jmp	 $L26709
$L26717:

; 151  : 	int nmodules = (int) (length / sizeof(HMODULE));

  00044	8b 85 58 f0 ff
	ff		 mov	 eax, DWORD PTR _length$[ebp]
  0004a	c1 e8 02	 shr	 eax, 2
  0004d	89 85 54 f0 ff
	ff		 mov	 DWORD PTR _nmodules$[ebp], eax

; 152  : 
; 153  : 	// Include the main executable of the process.
; 154  : 	modules[nmodules++] = GetModuleHandle(NULL);

  00053	6a 00		 push	 0
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  0005b	8b 8d 54 f0 ff
	ff		 mov	 ecx, DWORD PTR _nmodules$[ebp]
  00061	89 84 8d 5c f0
	ff ff		 mov	 DWORD PTR _modules$[ebp+ecx*4], eax
  00068	8b 95 54 f0 ff
	ff		 mov	 edx, DWORD PTR _nmodules$[ebp]
  0006e	83 c2 01	 add	 edx, 1
  00071	89 95 54 f0 ff
	ff		 mov	 DWORD PTR _nmodules$[ebp], edx

; 155  : 
; 156  : 	// Find out what module we're running in right now so we can avoid hooking it.
; 157  : 	HMODULE thismodule = NULL;

  00077	c7 85 50 f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _thismodule$[ebp], 0

; 158  : 	GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
; 159  : 		(char*) HookAllLoadedModules, &thismodule);

  00081	8d 85 50 f0 ff
	ff		 lea	 eax, DWORD PTR _thismodule$[ebp]
  00087	50		 push	 eax
  00088	68 00 00 00 00	 push	 OFFSET FLAT:?HookAllLoadedModules@@YAXXZ ; HookAllLoadedModules
  0008d	6a 04		 push	 4
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleExA@12

; 160  : 
; 161  : 	// Check each module against our list of previously hooked modules.
; 162  : 	for (int i = 0; i < nmodules; i++) {

  00095	c7 85 4c f0 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$26723[ebp], 0
  0009f	eb 0f		 jmp	 SHORT $L26724
$L26725:
  000a1	8b 85 4c f0 ff
	ff		 mov	 eax, DWORD PTR _i$26723[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 85 4c f0 ff
	ff		 mov	 DWORD PTR _i$26723[ebp], eax
$L26724:
  000b0	8b 85 4c f0 ff
	ff		 mov	 eax, DWORD PTR _i$26723[ebp]
  000b6	3b 85 54 f0 ff
	ff		 cmp	 eax, DWORD PTR _nmodules$[ebp]
  000bc	0f 8d a0 00 00
	00		 jge	 $L26709

; 163  : 		if (modules[i] != thismodule &&
; 164  : 			!bsearch(&(modules[i]), hooked, nhooked, sizeof(HMODULE), ComparePointers)) {

  000c2	8b 85 4c f0 ff
	ff		 mov	 eax, DWORD PTR _i$26723[ebp]
  000c8	8b 8c 85 5c f0
	ff ff		 mov	 ecx, DWORD PTR _modules$[ebp+eax*4]
  000cf	3b 8d 50 f0 ff
	ff		 cmp	 ecx, DWORD PTR _thismodule$[ebp]
  000d5	0f 84 82 00 00
	00		 je	 $L26728
  000db	68 00 00 00 00	 push	 OFFSET FLAT:?ComparePointers@@YAHPBX0@Z ; ComparePointers
  000e0	6a 04		 push	 4
  000e2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nhooked@?1??HookAllLoadedModules@@YAXXZ@4HA
  000e7	50		 push	 eax
  000e8	68 00 00 00 00	 push	 OFFSET FLAT:?hooked@?1??HookAllLoadedModules@@YAXXZ@4PAPAUHINSTANCE__@@A
  000ed	8b 8d 4c f0 ff
	ff		 mov	 ecx, DWORD PTR _i$26723[ebp]
  000f3	8d 94 8d 5c f0
	ff ff		 lea	 edx, DWORD PTR _modules$[ebp+ecx*4]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _bsearch
  00100	83 c4 14	 add	 esp, 20			; 00000014H
  00103	85 c0		 test	 eax, eax
  00105	75 56		 jne	 SHORT $L26728

; 165  : 			// We've found a new one.  Apply hooks and add it to our list.
; 166  : 			HookModule(modules[i]);

  00107	8b 85 4c f0 ff
	ff		 mov	 eax, DWORD PTR _i$26723[ebp]
  0010d	8b 8c 85 5c f0
	ff ff		 mov	 ecx, DWORD PTR _modules$[ebp+eax*4]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ?HookModule@@YAXPAUHINSTANCE__@@@Z ; HookModule
  0011a	83 c4 04	 add	 esp, 4

; 167  : 			hooked[nhooked++] = modules[i];

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nhooked@?1??HookAllLoadedModules@@YAXXZ@4HA
  00122	8b 8d 4c f0 ff
	ff		 mov	 ecx, DWORD PTR _i$26723[ebp]
  00128	8b 94 8d 5c f0
	ff ff		 mov	 edx, DWORD PTR _modules$[ebp+ecx*4]
  0012f	89 14 85 00 00
	00 00		 mov	 DWORD PTR ?hooked@?1??HookAllLoadedModules@@YAXXZ@4PAPAUHINSTANCE__@@A[eax*4], edx
  00136	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nhooked@?1??HookAllLoadedModules@@YAXXZ@4HA
  0013b	83 c0 01	 add	 eax, 1
  0013e	a3 00 00 00 00	 mov	 DWORD PTR ?nhooked@?1??HookAllLoadedModules@@YAXXZ@4HA, eax

; 168  : 			qsort(hooked, nhooked, sizeof(HMODULE), ComparePointers);

  00143	68 00 00 00 00	 push	 OFFSET FLAT:?ComparePointers@@YAHPBX0@Z ; ComparePointers
  00148	6a 04		 push	 4
  0014a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?nhooked@?1??HookAllLoadedModules@@YAXXZ@4HA
  0014f	50		 push	 eax
  00150	68 00 00 00 00	 push	 OFFSET FLAT:?hooked@?1??HookAllLoadedModules@@YAXXZ@4PAPAUHINSTANCE__@@A
  00155	e8 00 00 00 00	 call	 _qsort
  0015a	83 c4 10	 add	 esp, 16			; 00000010H
$L26728:

; 169  : 		}
; 170  : 	}

  0015d	e9 3f ff ff ff	 jmp	 $L26725
$L26709:

; 171  : }

  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx
  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
?HookAllLoadedModules@@YAXXZ ENDP			; HookAllLoadedModules
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?ComparePointers@@YAHPBX0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?ComparePointers@@YAHPBX0@Z PROC NEAR			; ComparePointers, COMDAT

; 137  : static int __cdecl ComparePointers(const void* a, const void* b) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 138  : 	return *((HMODULE*) a) - *((HMODULE*) b);

  00009	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	2b 01		 sub	 eax, DWORD PTR [ecx]
  00013	c1 f8 02	 sar	 eax, 2

; 139  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?ComparePointers@@YAHPBX0@Z ENDP			; ComparePointers
_TEXT	ENDS
PUBLIC	?HookLoadLibraryExW@@YGPAUHINSTANCE__@@PBGPAXK@Z ; HookLoadLibraryExW
PUBLIC	??_C@_0P@HECBOJPO@LoadLibraryExW?$AA@		; `string'
EXTRN	__imp__GetModuleHandleW@4:NEAR
;	COMDAT ??_C@_0P@HECBOJPO@LoadLibraryExW?$AA@
CONST	SEGMENT
??_C@_0P@HECBOJPO@LoadLibraryExW?$AA@ DB 'LoadLibraryExW', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?HookLoadLibraryExW@@YGPAUHINSTANCE__@@PBGPAXK@Z
_TEXT	SEGMENT
_result$ = -8						; size = 4
_newload$ = -1						; size = 1
_filename$ = 8						; size = 4
_handle$ = 12						; size = 4
_flags$ = 16						; size = 4
?HookLoadLibraryExW@@YGPAUHINSTANCE__@@PBGPAXK@Z PROC NEAR ; HookLoadLibraryExW, COMDAT

; 175  : HMODULE WINAPI HookLoadLibraryExW(LPCWSTR filename, HANDLE handle, DWORD flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 176  : 	bool newload = (GetModuleHandleW(filename) == NULL);

  00009	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax
  00018	88 45 ff	 mov	 BYTE PTR _newload$[ebp], al

; 177  : 	HMODULE result = ORIGINAL(LoadLibraryExW)(filename, handle, flags);

  0001b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _handle$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]
  00026	52		 push	 edx
  00027	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@HECBOJPO@LoadLibraryExW?$AA@
  0002c	e8 00 00 00 00	 call	 ?HookGetOriginal@@YAPAXPBD@Z ; HookGetOriginal
  00031	83 c4 04	 add	 esp, 4
  00034	ff d0		 call	 eax
  00036	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 178  : 	if (newload && result) HookAllLoadedModules();

  00039	0f b6 45 ff	 movzx	 eax, BYTE PTR _newload$[ebp]
  0003d	85 c0		 test	 eax, eax
  0003f	74 0b		 je	 SHORT $L26739
  00041	83 7d f8 00	 cmp	 DWORD PTR _result$[ebp], 0
  00045	74 05		 je	 SHORT $L26739
  00047	e8 00 00 00 00	 call	 ?HookAllLoadedModules@@YAXXZ ; HookAllLoadedModules
$L26739:

; 179  : 	return result;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]

; 180  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 0c 00	 ret	 12			; 0000000cH
?HookLoadLibraryExW@@YGPAUHINSTANCE__@@PBGPAXK@Z ENDP	; HookLoadLibraryExW
_TEXT	ENDS
PUBLIC	?HookLoadLibraryExA@@YGPAUHINSTANCE__@@PBDPAXK@Z ; HookLoadLibraryExA
PUBLIC	??_C@_0P@GILJFMCJ@LoadLibraryExA?$AA@		; `string'
;	COMDAT ??_C@_0P@GILJFMCJ@LoadLibraryExA?$AA@
CONST	SEGMENT
??_C@_0P@GILJFMCJ@LoadLibraryExA?$AA@ DB 'LoadLibraryExA', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?HookLoadLibraryExA@@YGPAUHINSTANCE__@@PBDPAXK@Z
_TEXT	SEGMENT
_result$ = -8						; size = 4
_newload$ = -1						; size = 1
_filename$ = 8						; size = 4
_handle$ = 12						; size = 4
_flags$ = 16						; size = 4
?HookLoadLibraryExA@@YGPAUHINSTANCE__@@PBDPAXK@Z PROC NEAR ; HookLoadLibraryExA, COMDAT

; 182  : HMODULE WINAPI HookLoadLibraryExA(LPCSTR filename, HANDLE handle, DWORD flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 183  : 	bool newload = (GetModuleHandleA(filename) == NULL);

  00009	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	40		 inc	 eax
  00018	88 45 ff	 mov	 BYTE PTR _newload$[ebp], al

; 184  : 	HMODULE result = ORIGINAL(LoadLibraryExA)(filename, handle, flags);

  0001b	8b 45 10	 mov	 eax, DWORD PTR _flags$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _handle$[ebp]
  00022	51		 push	 ecx
  00023	8b 55 08	 mov	 edx, DWORD PTR _filename$[ebp]
  00026	52		 push	 edx
  00027	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@GILJFMCJ@LoadLibraryExA?$AA@
  0002c	e8 00 00 00 00	 call	 ?HookGetOriginal@@YAPAXPBD@Z ; HookGetOriginal
  00031	83 c4 04	 add	 esp, 4
  00034	ff d0		 call	 eax
  00036	89 45 f8	 mov	 DWORD PTR _result$[ebp], eax

; 185  : 	if (newload && result) HookAllLoadedModules();

  00039	0f b6 45 ff	 movzx	 eax, BYTE PTR _newload$[ebp]
  0003d	85 c0		 test	 eax, eax
  0003f	74 0b		 je	 SHORT $L26749
  00041	83 7d f8 00	 cmp	 DWORD PTR _result$[ebp], 0
  00045	74 05		 je	 SHORT $L26749
  00047	e8 00 00 00 00	 call	 ?HookAllLoadedModules@@YAXXZ ; HookAllLoadedModules
$L26749:

; 186  : 	return result;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _result$[ebp]

; 187  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 0c 00	 ret	 12			; 0000000cH
?HookLoadLibraryExA@@YGPAUHINSTANCE__@@PBDPAXK@Z ENDP	; HookLoadLibraryExA
_TEXT	ENDS
PUBLIC	?HookLoadLibraryW@@YGPAUHINSTANCE__@@PBG@Z	; HookLoadLibraryW
; Function compile flags: /Odt /ZI
;	COMDAT ?HookLoadLibraryW@@YGPAUHINSTANCE__@@PBG@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
?HookLoadLibraryW@@YGPAUHINSTANCE__@@PBG@Z PROC NEAR	; HookLoadLibraryW, COMDAT

; 189  : HMODULE WINAPI HookLoadLibraryW(LPCWSTR filename) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 190  : 	return HookLoadLibraryExW(filename, NULL, 0);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?HookLoadLibraryExW@@YGPAUHINSTANCE__@@PBGPAXK@Z ; HookLoadLibraryExW

; 191  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?HookLoadLibraryW@@YGPAUHINSTANCE__@@PBG@Z ENDP		; HookLoadLibraryW
_TEXT	ENDS
PUBLIC	?HookLoadLibraryA@@YGPAUHINSTANCE__@@PBD@Z	; HookLoadLibraryA
; Function compile flags: /Odt /ZI
;	COMDAT ?HookLoadLibraryA@@YGPAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
?HookLoadLibraryA@@YGPAUHINSTANCE__@@PBD@Z PROC NEAR	; HookLoadLibraryA, COMDAT

; 193  : HMODULE WINAPI HookLoadLibraryA(LPCSTR filename) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 194  : 	return HookLoadLibraryExA(filename, NULL, 0);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	8b 45 08	 mov	 eax, DWORD PTR _filename$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?HookLoadLibraryExA@@YGPAUHINSTANCE__@@PBDPAXK@Z ; HookLoadLibraryExA

; 195  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?HookLoadLibraryA@@YGPAUHINSTANCE__@@PBD@Z ENDP		; HookLoadLibraryA
_TEXT	ENDS
PUBLIC	??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@		; `string'
PUBLIC	??_C@_0N@KCFDJLIF@LoadLibraryW?$AA@		; `string'
PUBLIC	?HookAllLoadedAndFutureModules@@YAXXZ		; HookAllLoadedAndFutureModules
;	COMDAT ??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@
CONST	SEGMENT
??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@ DB 'LoadLibraryA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KCFDJLIF@LoadLibraryW?$AA@
CONST	SEGMENT
??_C@_0N@KCFDJLIF@LoadLibraryW?$AA@ DB 'LoadLibraryW', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?HookAllLoadedAndFutureModules@@YAXXZ
_TEXT	SEGMENT
?HookAllLoadedAndFutureModules@@YAXXZ PROC NEAR		; HookAllLoadedAndFutureModules, COMDAT

; 198  : void HookAllLoadedAndFutureModules() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 199  : 	HookAddHook("kernel32", "LoadLibraryA", HookLoadLibraryA);

  00009	68 00 00 00 00	 push	 OFFSET FLAT:?HookLoadLibraryA@@YGPAUHINSTANCE__@@PBD@Z ; HookLoadLibraryA
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08PNLNEKOB@kernel32?$AA@
  00018	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 	HookAddHook("kernel32", "LoadLibraryW", HookLoadLibraryW);

  00020	68 00 00 00 00	 push	 OFFSET FLAT:?HookLoadLibraryW@@YGPAUHINSTANCE__@@PBG@Z ; HookLoadLibraryW
  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@KCFDJLIF@LoadLibraryW?$AA@
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08PNLNEKOB@kernel32?$AA@
  0002f	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 201  : 	HookAddHook("kernel32", "LoadLibraryExA", HookLoadLibraryExA);

  00037	68 00 00 00 00	 push	 OFFSET FLAT:?HookLoadLibraryExA@@YGPAUHINSTANCE__@@PBDPAXK@Z ; HookLoadLibraryExA
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@GILJFMCJ@LoadLibraryExA?$AA@
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08PNLNEKOB@kernel32?$AA@
  00046	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 	HookAddHook("kernel32", "LoadLibraryExW", HookLoadLibraryExW);

  0004e	68 00 00 00 00	 push	 OFFSET FLAT:?HookLoadLibraryExW@@YGPAUHINSTANCE__@@PBGPAXK@Z ; HookLoadLibraryExW
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@HECBOJPO@LoadLibraryExW?$AA@
  00058	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08PNLNEKOB@kernel32?$AA@
  0005d	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 203  : 	HookAllLoadedModules();

  00065	e8 00 00 00 00	 call	 ?HookAllLoadedModules@@YAXXZ ; HookAllLoadedModules

; 204  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
?HookAllLoadedAndFutureModules@@YAXXZ ENDP		; HookAllLoadedAndFutureModules
_TEXT	ENDS
END
