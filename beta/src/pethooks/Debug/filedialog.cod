; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\filedialog.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_1M@MCMFDKPF@?$AAt?$AAy?$AAp?$AAe?$AA?3?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@PHCNNKIO@?$AAn?$AAa?$AAm?$AAe?$AA?3?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GEHIOJLB@Snake?5List?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSelection@@YAHVAccessibleElement@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSelection@@YAXVAccessibleElement@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendKey@@YAXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FileDialogInfo
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GAccessibleElement@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FileDialogSubmit
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@G@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@G@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@G@std@@QAEXPAGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@G@std@@QAEPAGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@G@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@G@std@@YAPAGIPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?assign@?$char_traits@G@std@@SAXAAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@G@std@@SAIPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	??_GAccessibleElement@@QAEPAXI@Z		; AccessibleElement::`scalar deleting destructor'
PUBLIC	_FileDialogInfo
EXTRN	_free:NEAR
EXTRN	_malloc:NEAR
EXTRN	??0AccessibleElement@@QAE@AAV0@@Z:NEAR		; AccessibleElement::AccessibleElement
EXTRN	??0AccessibleElement@@QAE@PAUHWND__@@@Z:NEAR	; AccessibleElement::AccessibleElement
EXTRN	??1AccessibleElement@@QAE@XZ:NEAR		; AccessibleElement::~AccessibleElement
EXTRN	?GetName@AccessibleElement@@QAEPAGXZ:NEAR	; AccessibleElement::GetName
EXTRN	?GetValue@AccessibleElement@@QAEPAGXZ:NEAR	; AccessibleElement::GetValue
EXTRN	?CountChildren@AccessibleElement@@QAEHXZ:NEAR	; AccessibleElement::CountChildren
EXTRN	?GetChildren@AccessibleElement@@QAE?AVAccessibleChildIterator@@XZ:NEAR ; AccessibleElement::GetChildren
EXTRN	??1AccessibleChildIterator@@QAE@XZ:NEAR		; AccessibleChildIterator::~AccessibleChildIterator
EXTRN	?GetNext@AccessibleChildIterator@@QAE?AVAccessibleElement@@XZ:NEAR ; AccessibleChildIterator::GetNext
EXTRN	__imp__GetWindowTextW@12:NEAR
EXTRN	??0Message@@QAE@PBEI@Z:NEAR			; Message::Message
EXTRN	??1Message@@QAE@XZ:NEAR				; Message::~Message
EXTRN	?cast@Message@@QAEXPAXI@Z:NEAR			; Message::cast
EXTRN	??0Serializer@@QAE@I@Z:NEAR			; Serializer::Serializer
EXTRN	??1Serializer@@UAE@XZ:NEAR			; Serializer::~Serializer
EXTRN	?promise@Serializer@@QAEXPBG@Z:NEAR		; Serializer::promise
EXTRN	?send@Serializer@@QAEXPBXI@Z:NEAR		; Serializer::send
EXTRN	?send@Serializer@@QAEXPBG@Z:NEAR		; Serializer::send
EXTRN	?dump@Serializer@@QAEIPAEI@Z:NEAR		; Serializer::dump
; Function compile flags: /Odt /ZI
; File c:\documents and settings\marcstgr\my documents\visual studio projects\beta\src\pethooks\filedialog.cpp
;	COMDAT _FileDialogInfo
_TEXT	SEGMENT
tv225 = -2240						; size = 4
tv220 = -2240						; size = 4
$T51404 = -2236						; size = 4
$T51405 = -2232						; size = 4
$T51406 = -2228						; size = 4
$T51407 = -2224						; size = 4
$T51408 = -2220						; size = 4
$T51411 = -2216						; size = 4
$T51412 = -2212						; size = 4
$T51415 = -2208						; size = 4
_i$51098 = -2140					; size = 4
_i$51094 = -2136					; size = 4
_reply$ = -2132						; size = 20
_child$51091 = -2112					; size = 24
_i$51087 = -2088					; size = 4
_children$ = -2084					; size = 16
_title$ = -2068						; size = 2000
_info$ = -68						; size = 4
_size$ = -64						; size = 4
_nfiletypes$ = -60					; size = 4
_typelist$ = -56					; size = 4
_filename$ = -52					; size = 4
_dialog$ = -48						; size = 24
_window$ = -24						; size = 4
_request$ = -20						; size = 20
_buffer$ = 8						; size = 4
_bufsize$ = 12						; size = 4
_FileDialogInfo PROC NEAR				; COMDAT

; 87   : EXPORT size_t __cdecl FileDialogInfo(BYTE* buffer, size_t bufsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 08 00
	00		 sub	 esp, 2240		; 000008c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 88   : 	Message request(buffer, bufsize);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _bufsize$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00013	51		 push	 ecx
  00014	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  00017	e8 00 00 00 00	 call	 ??0Message@@QAE@PBEI@Z	; Message::Message

; 89   : 	HWND* window = NULL;

  0001c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _window$[ebp], 0

; 90   : 	request.cast(&window, sizeof(*window));

  00023	6a 04		 push	 4
  00025	8d 45 e8	 lea	 eax, DWORD PTR _window$[ebp]
  00028	50		 push	 eax
  00029	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  0002c	e8 00 00 00 00	 call	 ?cast@Message@@QAEXPAXI@Z ; Message::cast

; 91   : 
; 92   : 	// Find the relevant elements of the file dialog.
; 93   : 	AccessibleElement dialog(*window);

  00031	8b 45 e8	 mov	 eax, DWORD PTR _window$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	51		 push	 ecx
  00037	8d 4d d0	 lea	 ecx, DWORD PTR _dialog$[ebp]
  0003a	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@PAUHWND__@@@Z ; AccessibleElement::AccessibleElement

; 94   : 	AccessibleElement* filename = NULL;

  0003f	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _filename$[ebp], 0

; 95   : 	AccessibleElement* typelist = NULL;

  00046	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _typelist$[ebp], 0

; 96   : 	if (!FindElements(dialog, &filename, &typelist)) return 0;

  0004d	8d 45 c8	 lea	 eax, DWORD PTR _typelist$[ebp]
  00050	50		 push	 eax
  00051	8d 4d cc	 lea	 ecx, DWORD PTR _filename$[ebp]
  00054	51		 push	 ecx
  00055	83 ec 18	 sub	 esp, 24			; 00000018H
  00058	8b cc		 mov	 ecx, esp
  0005a	89 a5 44 f7 ff
	ff		 mov	 DWORD PTR $T51404[ebp], esp
  00060	8d 55 d0	 lea	 edx, DWORD PTR _dialog$[ebp]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  00069	e8 00 00 00 00	 call	 ?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z ; FindElements
  0006e	83 c4 20	 add	 esp, 32			; 00000020H
  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	75 25		 jne	 SHORT $L51075
  00078	c7 85 48 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T51405[ebp], 0
  00082	8d 4d d0	 lea	 ecx, DWORD PTR _dialog$[ebp]
  00085	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  0008a	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  0008d	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  00092	8b 85 48 f7 ff
	ff		 mov	 eax, DWORD PTR $T51405[ebp]
  00098	e9 ee 02 00 00	 jmp	 $L51068
$L51075:

; 97   : 
; 98   : 	// Allocate an extended FILETYPEINFO structure of the right size.
; 99   : 	int nfiletypes = typelist->CountChildren();

  0009d	8b 4d c8	 mov	 ecx, DWORD PTR _typelist$[ebp]
  000a0	e8 00 00 00 00	 call	 ?CountChildren@AccessibleElement@@QAEHXZ ; AccessibleElement::CountChildren
  000a5	89 45 c4	 mov	 DWORD PTR _nfiletypes$[ebp], eax

; 100  : 	size_t size = sizeof(FILEDIALOGINFO) + sizeof(WCHAR*) * nfiletypes;

  000a8	8b 45 c4	 mov	 eax, DWORD PTR _nfiletypes$[ebp]
  000ab	8d 0c 85 14 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+20]
  000b2	89 4d c0	 mov	 DWORD PTR _size$[ebp], ecx

; 101  : 	FILEDIALOGINFO* info = (FILEDIALOGINFO*) malloc(size);

  000b5	8b 45 c0	 mov	 eax, DWORD PTR _size$[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _malloc
  000be	83 c4 04	 add	 esp, 4
  000c1	89 45 bc	 mov	 DWORD PTR _info$[ebp], eax

; 102  : 
; 103  : 	// Fill in the contents of the FILEDIALOGINFO structure.
; 104  : 	WCHAR title[1000];
; 105  : 	GetWindowTextW(*window, title, 1000);

  000c4	68 e8 03 00 00	 push	 1000			; 000003e8H
  000c9	8d 85 ec f7 ff
	ff		 lea	 eax, DWORD PTR _title$[ebp]
  000cf	50		 push	 eax
  000d0	8b 4d e8	 mov	 ecx, DWORD PTR _window$[ebp]
  000d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d5	52		 push	 edx
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetWindowTextW@12

; 106  : 	info->title = title;

  000dc	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  000df	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _title$[ebp]
  000e5	89 08		 mov	 DWORD PTR [eax], ecx

; 107  : 	info->path = filename->GetValue();

  000e7	8b 4d cc	 mov	 ecx, DWORD PTR _filename$[ebp]
  000ea	e8 00 00 00 00	 call	 ?GetValue@AccessibleElement@@QAEPAGXZ ; AccessibleElement::GetValue
  000ef	8b 4d bc	 mov	 ecx, DWORD PTR _info$[ebp]
  000f2	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 108  : 	info->filetypelabel = typelist->GetName();

  000f5	8b 4d c8	 mov	 ecx, DWORD PTR _typelist$[ebp]
  000f8	e8 00 00 00 00	 call	 ?GetName@AccessibleElement@@QAEPAGXZ ; AccessibleElement::GetName
  000fd	8b 4d bc	 mov	 ecx, DWORD PTR _info$[ebp]
  00100	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 109  : 	info->filetype = GetSelection(*typelist) + 1;

  00103	83 ec 18	 sub	 esp, 24			; 00000018H
  00106	8b cc		 mov	 ecx, esp
  00108	89 a5 4c f7 ff
	ff		 mov	 DWORD PTR $T51406[ebp], esp
  0010e	8b 45 c8	 mov	 eax, DWORD PTR _typelist$[ebp]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  00117	e8 00 00 00 00	 call	 ?GetSelection@@YAHVAccessibleElement@@@Z ; GetSelection
  0011c	83 c4 18	 add	 esp, 24			; 00000018H
  0011f	83 c0 01	 add	 eax, 1
  00122	8b 4d bc	 mov	 ecx, DWORD PTR _info$[ebp]
  00125	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 110  : 	info->nfiletypes = nfiletypes;

  00128	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  0012b	8b 4d c4	 mov	 ecx, DWORD PTR _nfiletypes$[ebp]
  0012e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 111  : 	AccessibleChildIterator children = typelist->GetChildren();

  00131	8d 85 dc f7 ff
	ff		 lea	 eax, DWORD PTR _children$[ebp]
  00137	50		 push	 eax
  00138	8b 4d c8	 mov	 ecx, DWORD PTR _typelist$[ebp]
  0013b	e8 00 00 00 00	 call	 ?GetChildren@AccessibleElement@@QAE?AVAccessibleChildIterator@@XZ ; AccessibleElement::GetChildren

; 112  : 	for (int i = 0; i < nfiletypes; i++) {

  00140	c7 85 d8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$51087[ebp], 0
  0014a	eb 0f		 jmp	 SHORT $L51088
$L51089:
  0014c	8b 85 d8 f7 ff
	ff		 mov	 eax, DWORD PTR _i$51087[ebp]
  00152	83 c0 01	 add	 eax, 1
  00155	89 85 d8 f7 ff
	ff		 mov	 DWORD PTR _i$51087[ebp], eax
$L51088:
  0015b	8b 85 d8 f7 ff
	ff		 mov	 eax, DWORD PTR _i$51087[ebp]
  00161	3b 45 c4	 cmp	 eax, DWORD PTR _nfiletypes$[ebp]
  00164	7d 37		 jge	 SHORT $L51090

; 113  : 		AccessibleElement child = children.GetNext();

  00166	8d 85 c0 f7 ff
	ff		 lea	 eax, DWORD PTR _child$51091[ebp]
  0016c	50		 push	 eax
  0016d	8d 8d dc f7 ff
	ff		 lea	 ecx, DWORD PTR _children$[ebp]
  00173	e8 00 00 00 00	 call	 ?GetNext@AccessibleChildIterator@@QAE?AVAccessibleElement@@XZ ; AccessibleChildIterator::GetNext

; 114  : 		info->filetypes[i] = child.GetName();

  00178	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _child$51091[ebp]
  0017e	e8 00 00 00 00	 call	 ?GetName@AccessibleElement@@QAEPAGXZ ; AccessibleElement::GetName
  00183	8b 8d d8 f7 ff
	ff		 mov	 ecx, DWORD PTR _i$51087[ebp]
  00189	8b 55 bc	 mov	 edx, DWORD PTR _info$[ebp]
  0018c	89 44 8a 14	 mov	 DWORD PTR [edx+ecx*4+20], eax

; 115  : 	}

  00190	8d 8d c0 f7 ff
	ff		 lea	 ecx, DWORD PTR _child$51091[ebp]
  00196	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  0019b	eb af		 jmp	 SHORT $L51089
$L51090:

; 116  : 
; 117  : 	// Serialize the FILEDIALOGINFO structure to form the reply.
; 118  : 	Serializer reply(size);

  0019d	8b 45 c0	 mov	 eax, DWORD PTR _size$[ebp]
  001a0	50		 push	 eax
  001a1	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  001a7	e8 00 00 00 00	 call	 ??0Serializer@@QAE@I@Z	; Serializer::Serializer

; 119  : 	reply.promise(info->title);

  001ac	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  001af	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b1	51		 push	 ecx
  001b2	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  001b8	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBG@Z ; Serializer::promise

; 120  : 	reply.promise(info->path);

  001bd	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  001c0	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c3	51		 push	 ecx
  001c4	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  001ca	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBG@Z ; Serializer::promise

; 121  : 	reply.promise(info->filetypelabel);

  001cf	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  001d2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001d5	51		 push	 ecx
  001d6	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  001dc	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBG@Z ; Serializer::promise

; 122  : 	reply.send(&(info->filetype), sizeof(info->filetype));

  001e1	6a 04		 push	 4
  001e3	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  001e6	83 c0 0c	 add	 eax, 12			; 0000000cH
  001e9	50		 push	 eax
  001ea	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  001f0	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 123  : 	reply.send(&(info->nfiletypes), sizeof(info->nfiletypes));

  001f5	6a 04		 push	 4
  001f7	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  001fa	83 c0 10	 add	 eax, 16			; 00000010H
  001fd	50		 push	 eax
  001fe	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  00204	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 124  : 	for (int i = 0; i < nfiletypes; i++) reply.promise(info->filetypes[i]);

  00209	c7 85 a8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$51094[ebp], 0
  00213	eb 0f		 jmp	 SHORT $L51095
$L51096:
  00215	8b 85 a8 f7 ff
	ff		 mov	 eax, DWORD PTR _i$51094[ebp]
  0021b	83 c0 01	 add	 eax, 1
  0021e	89 85 a8 f7 ff
	ff		 mov	 DWORD PTR _i$51094[ebp], eax
$L51095:
  00224	8b 85 a8 f7 ff
	ff		 mov	 eax, DWORD PTR _i$51094[ebp]
  0022a	3b 45 c4	 cmp	 eax, DWORD PTR _nfiletypes$[ebp]
  0022d	7d 1b		 jge	 SHORT $L51097
  0022f	8b 85 a8 f7 ff
	ff		 mov	 eax, DWORD PTR _i$51094[ebp]
  00235	8b 4d bc	 mov	 ecx, DWORD PTR _info$[ebp]
  00238	8b 54 81 14	 mov	 edx, DWORD PTR [ecx+eax*4+20]
  0023c	52		 push	 edx
  0023d	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  00243	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBG@Z ; Serializer::promise
  00248	eb cb		 jmp	 SHORT $L51096
$L51097:

; 125  : 	reply.send(info->title);

  0024a	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  0024d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024f	51		 push	 ecx
  00250	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  00256	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBG@Z ; Serializer::send

; 126  : 	reply.send(info->path);

  0025b	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  0025e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00261	51		 push	 ecx
  00262	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  00268	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBG@Z ; Serializer::send

; 127  : 	reply.send(info->filetypelabel);

  0026d	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  00270	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00273	51		 push	 ecx
  00274	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  0027a	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBG@Z ; Serializer::send

; 128  : 	for (int i = 0; i < nfiletypes; i++) reply.send(info->filetypes[i]);

  0027f	c7 85 a4 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$51098[ebp], 0
  00289	eb 0f		 jmp	 SHORT $L51099
$L51100:
  0028b	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _i$51098[ebp]
  00291	83 c0 01	 add	 eax, 1
  00294	89 85 a4 f7 ff
	ff		 mov	 DWORD PTR _i$51098[ebp], eax
$L51099:
  0029a	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _i$51098[ebp]
  002a0	3b 45 c4	 cmp	 eax, DWORD PTR _nfiletypes$[ebp]
  002a3	7d 1b		 jge	 SHORT $L51101
  002a5	8b 85 a4 f7 ff
	ff		 mov	 eax, DWORD PTR _i$51098[ebp]
  002ab	8b 4d bc	 mov	 ecx, DWORD PTR _info$[ebp]
  002ae	8b 54 81 14	 mov	 edx, DWORD PTR [ecx+eax*4+20]
  002b2	52		 push	 edx
  002b3	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  002b9	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBG@Z ; Serializer::send
  002be	eb cb		 jmp	 SHORT $L51100
$L51101:

; 129  : 	free(info);

  002c0	8b 45 bc	 mov	 eax, DWORD PTR _info$[ebp]
  002c3	50		 push	 eax
  002c4	e8 00 00 00 00	 call	 _free
  002c9	83 c4 04	 add	 esp, 4

; 130  : 
; 131  : 	delete filename;

  002cc	8b 45 cc	 mov	 eax, DWORD PTR _filename$[ebp]
  002cf	89 85 54 f7 ff
	ff		 mov	 DWORD PTR $T51408[ebp], eax
  002d5	8b 8d 54 f7 ff
	ff		 mov	 ecx, DWORD PTR $T51408[ebp]
  002db	89 8d 50 f7 ff
	ff		 mov	 DWORD PTR $T51407[ebp], ecx
  002e1	83 bd 50 f7 ff
	ff 00		 cmp	 DWORD PTR $T51407[ebp], 0
  002e8	74 15		 je	 SHORT $L51409
  002ea	6a 01		 push	 1
  002ec	8b 8d 50 f7 ff
	ff		 mov	 ecx, DWORD PTR $T51407[ebp]
  002f2	e8 00 00 00 00	 call	 ??_GAccessibleElement@@QAEPAXI@Z
  002f7	89 85 40 f7 ff
	ff		 mov	 DWORD PTR tv220[ebp], eax
  002fd	eb 0a		 jmp	 SHORT $L51410
$L51409:
  002ff	c7 85 40 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv220[ebp], 0
$L51410:

; 132  : 	delete typelist;

  00309	8b 45 c8	 mov	 eax, DWORD PTR _typelist$[ebp]
  0030c	89 85 5c f7 ff
	ff		 mov	 DWORD PTR $T51412[ebp], eax
  00312	8b 8d 5c f7 ff
	ff		 mov	 ecx, DWORD PTR $T51412[ebp]
  00318	89 8d 58 f7 ff
	ff		 mov	 DWORD PTR $T51411[ebp], ecx
  0031e	83 bd 58 f7 ff
	ff 00		 cmp	 DWORD PTR $T51411[ebp], 0
  00325	74 15		 je	 SHORT $L51413
  00327	6a 01		 push	 1
  00329	8b 8d 58 f7 ff
	ff		 mov	 ecx, DWORD PTR $T51411[ebp]
  0032f	e8 00 00 00 00	 call	 ??_GAccessibleElement@@QAEPAXI@Z
  00334	89 85 40 f7 ff
	ff		 mov	 DWORD PTR tv225[ebp], eax
  0033a	eb 0a		 jmp	 SHORT $L51414
$L51413:
  0033c	c7 85 40 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR tv225[ebp], 0
$L51414:

; 133  : 	return reply.dump(buffer, bufsize);

  00346	8b 45 0c	 mov	 eax, DWORD PTR _bufsize$[ebp]
  00349	50		 push	 eax
  0034a	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0034d	51		 push	 ecx
  0034e	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  00354	e8 00 00 00 00	 call	 ?dump@Serializer@@QAEIPAEI@Z ; Serializer::dump
  00359	89 85 60 f7 ff
	ff		 mov	 DWORD PTR $T51415[ebp], eax
  0035f	8d 8d ac f7 ff
	ff		 lea	 ecx, DWORD PTR _reply$[ebp]
  00365	e8 00 00 00 00	 call	 ??1Serializer@@UAE@XZ	; Serializer::~Serializer
  0036a	8d 8d dc f7 ff
	ff		 lea	 ecx, DWORD PTR _children$[ebp]
  00370	e8 00 00 00 00	 call	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
  00375	8d 4d d0	 lea	 ecx, DWORD PTR _dialog$[ebp]
  00378	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  0037d	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  00380	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  00385	8b 85 60 f7 ff
	ff		 mov	 eax, DWORD PTR $T51415[ebp]
$L51068:

; 134  : }

  0038b	5f		 pop	 edi
  0038c	5e		 pop	 esi
  0038d	5b		 pop	 ebx
  0038e	8b e5		 mov	 esp, ebp
  00390	5d		 pop	 ebp
  00391	c3		 ret	 0
_FileDialogInfo ENDP
_TEXT	ENDS
PUBLIC	??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
PUBLIC	??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::~basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
PUBLIC	??_C@_1M@MCMFDKPF@?$AAt?$AAy?$AAp?$AAe?$AA?3?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PHCNNKIO@?$AAn?$AAa?$AAm?$AAe?$AA?3?$AA?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	?GetRole@AccessibleElement@@QAEHXZ:NEAR		; AccessibleElement::GetRole
EXTRN	?HasNext@AccessibleChildIterator@@QAE_NXZ:NEAR	; AccessibleChildIterator::HasNext
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?EndsWith@@YA_NV?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@0@Z:NEAR ; EndsWith
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$5
	DD	02H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$6
	DD	02H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$8
	DD	02H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$9
	DD	02H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$11
	DD	08H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$12
	DD	09H
	DD	FLAT:__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$13
__ehfuncinfo$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z DD 019930520H
	DD	0bH
	DD	FLAT:__unwindtable$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_1M@MCMFDKPF@?$AAt?$AAy?$AAp?$AAe?$AA?3?$AA?$AA@
CONST	SEGMENT
??_C@_1M@MCMFDKPF@?$AAt?$AAy?$AAp?$AAe?$AA?3?$AA?$AA@ DB 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ':', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PHCNNKIO@?$AAn?$AAa?$AAm?$AAe?$AA?3?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PHCNNKIO@?$AAn?$AAa?$AAm?$AAe?$AA?3?$AA?$AA@ DB 'n', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, ':', 00H, 00H, 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z
_TEXT	SEGMENT
tv303 = -233						; size = 1
tv296 = -233						; size = 1
tv289 = -233						; size = 1
tv306 = -232						; size = 4
tv299 = -232						; size = 4
tv292 = -232						; size = 4
tv302 = -228						; size = 4
tv295 = -228						; size = 4
tv288 = -228						; size = 4
tv325 = -224						; size = 4
tv323 = -224						; size = 4
tv318 = -224						; size = 4
tv314 = -224						; size = 4
tv246 = -224						; size = 4
tv192 = -224						; size = 4
tv153 = -224						; size = 4
tv81 = -224						; size = 4
tv74 = -224						; size = 4
$T51418 = -220						; size = 4
$T51419 = -216						; size = 4
$T51420 = -212						; size = 4
$T51421 = -208						; size = 4
$T51424 = -204						; size = 4
$T51425 = -200						; size = 4
$T51426 = -196						; size = 4
$T51427 = -192						; size = 4
$T51430 = -188						; size = 4
$T51431 = -184						; size = 4
$T51432 = -180						; size = 4
$T51433 = -176						; size = 4
$T51436 = -172						; size = 4
$T51437 = -168						; size = 4
$T51438 = -162						; size = 1
$T51439 = -161						; size = 1
_item$51017 = -96					; size = 24
_items$51012 = -72					; size = 16
_name$50440 = -56					; size = 4
_child$50438 = -52					; size = 24
_children$50433 = -28					; size = 16
__$EHRec$ = -12						; size = 12
_element$ = 8						; size = 24
_filename$ = 32						; size = 4
_typelist$ = 36						; size = 4
?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z PROC NEAR ; FindElements, COMDAT

; 14   : 						 AccessibleElement** typelist) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 15   : 	for (AccessibleChildIterator children = element.GetChildren(); children.HasNext();) {

  00028	8d 45 e4	 lea	 eax, DWORD PTR _children$50433[ebp]
  0002b	50		 push	 eax
  0002c	8d 4d 08	 lea	 ecx, DWORD PTR _element$[ebp]
  0002f	e8 00 00 00 00	 call	 ?GetChildren@AccessibleElement@@QAE?AVAccessibleChildIterator@@XZ ; AccessibleElement::GetChildren
  00034	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
$L50436:
  00038	8d 4d e4	 lea	 ecx, DWORD PTR _children$50433[ebp]
  0003b	e8 00 00 00 00	 call	 ?HasNext@AccessibleChildIterator@@QAE_NXZ ; AccessibleChildIterator::HasNext
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	0f 84 c7 03 00
	00		 je	 $L50437

; 16   : 		AccessibleElement child = children.GetNext();

  0004b	8d 45 cc	 lea	 eax, DWORD PTR _child$50438[ebp]
  0004e	50		 push	 eax
  0004f	8d 4d e4	 lea	 ecx, DWORD PTR _children$50433[ebp]
  00052	e8 00 00 00 00	 call	 ?GetNext@AccessibleChildIterator@@QAE?AVAccessibleElement@@XZ ; AccessibleChildIterator::GetNext
  00057	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 17   : 		WCHAR* name = child.GetName();

  0005b	8d 4d cc	 lea	 ecx, DWORD PTR _child$50438[ebp]
  0005e	e8 00 00 00 00	 call	 ?GetName@AccessibleElement@@QAEPAGXZ ; AccessibleElement::GetName
  00063	89 45 c8	 mov	 DWORD PTR _name$50440[ebp], eax

; 18   :         switch (child.GetRole()) {

  00066	8d 4d cc	 lea	 ecx, DWORD PTR _child$50438[ebp]
  00069	e8 00 00 00 00	 call	 ?GetRole@AccessibleElement@@QAEHXZ ; AccessibleElement::GetRole
  0006e	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  00074	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  0007a	83 e8 09	 sub	 eax, 9
  0007d	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  00083	83 bd 20 ff ff
	ff 25		 cmp	 DWORD PTR tv81[ebp], 37	; 00000025H
  0008a	0f 87 2b 03 00
	00		 ja	 $L50442
  00090	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv81[ebp]
  00096	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $L51460[ecx]
  0009d	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $L51463[edx*4]
$L50445:

; 19   :             case ROLE_SYSTEM_LIST:
; 20   : 				if (name && EndsWith(name, L"type:")) *typelist = new AccessibleElement(child);

  000a4	83 7d c8 00	 cmp	 DWORD PTR _name$50440[ebp], 0
  000a8	0f 84 bb 00 00
	00		 je	 $L50993
  000ae	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000b1	8b cc		 mov	 ecx, esp
  000b3	89 a5 24 ff ff
	ff		 mov	 DWORD PTR $T51418[ebp], esp
  000b9	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@MCMFDKPF@?$AAt?$AAy?$AAp?$AAe?$AA?3?$AA?$AA@
  000be	e8 00 00 00 00	 call	 ??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
  000c3	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], eax
  000c9	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]
  000cf	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv288[ebp], eax
  000d5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000d9	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000dc	8b cc		 mov	 ecx, esp
  000de	89 a5 28 ff ff
	ff		 mov	 DWORD PTR $T51419[ebp], esp
  000e4	8b 55 c8	 mov	 edx, DWORD PTR _name$50440[ebp]
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
  000ed	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv292[ebp], eax
  000f3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000f7	e8 00 00 00 00	 call	 ?EndsWith@@YA_NV?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@0@Z ; EndsWith
  000fc	83 c4 38	 add	 esp, 56			; 00000038H
  000ff	88 85 17 ff ff
	ff		 mov	 BYTE PTR tv289[ebp], al
  00105	0f b6 85 17 ff
	ff ff		 movzx	 eax, BYTE PTR tv289[ebp]
  0010c	85 c0		 test	 eax, eax
  0010e	74 59		 je	 SHORT $L50993
  00110	6a 18		 push	 24			; 00000018H
  00112	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00117	83 c4 04	 add	 esp, 4
  0011a	89 85 30 ff ff
	ff		 mov	 DWORD PTR $T51421[ebp], eax
  00120	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00124	83 bd 30 ff ff
	ff 00		 cmp	 DWORD PTR $T51421[ebp], 0
  0012b	74 17		 je	 SHORT $L51422
  0012d	8d 45 cc	 lea	 eax, DWORD PTR _child$50438[ebp]
  00130	50		 push	 eax
  00131	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR $T51421[ebp]
  00137	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  0013c	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv153[ebp], eax
  00142	eb 0a		 jmp	 SHORT $L51423
$L51422:
  00144	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv153[ebp], 0
$L51423:
  0014e	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv153[ebp]
  00154	89 8d 2c ff ff
	ff		 mov	 DWORD PTR $T51420[ebp], ecx
  0015a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0015e	8b 55 24	 mov	 edx, DWORD PTR _typelist$[ebp]
  00161	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T51420[ebp]
  00167	89 02		 mov	 DWORD PTR [edx], eax
$L50993:

; 21   :                 break;

  00169	e9 4d 02 00 00	 jmp	 $L50442
$L50999:

; 22   :             case ROLE_SYSTEM_TEXT:
; 23   :                 if (name && EndsWith(name, L"name:")) *filename = new AccessibleElement(child);

  0016e	83 7d c8 00	 cmp	 DWORD PTR _name$50440[ebp], 0
  00172	0f 84 bb 00 00
	00		 je	 $L51002
  00178	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0017b	8b cc		 mov	 ecx, esp
  0017d	89 a5 34 ff ff
	ff		 mov	 DWORD PTR $T51424[ebp], esp
  00183	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@PHCNNKIO@?$AAn?$AAa?$AAm?$AAe?$AA?3?$AA?$AA@
  00188	e8 00 00 00 00	 call	 ??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
  0018d	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv323[ebp], eax
  00193	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv323[ebp]
  00199	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv295[ebp], eax
  0019f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  001a3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  001a6	8b cc		 mov	 ecx, esp
  001a8	89 a5 38 ff ff
	ff		 mov	 DWORD PTR $T51425[ebp], esp
  001ae	8b 55 c8	 mov	 edx, DWORD PTR _name$50440[ebp]
  001b1	52		 push	 edx
  001b2	e8 00 00 00 00	 call	 ??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
  001b7	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv299[ebp], eax
  001bd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001c1	e8 00 00 00 00	 call	 ?EndsWith@@YA_NV?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@0@Z ; EndsWith
  001c6	83 c4 38	 add	 esp, 56			; 00000038H
  001c9	88 85 17 ff ff
	ff		 mov	 BYTE PTR tv296[ebp], al
  001cf	0f b6 85 17 ff
	ff ff		 movzx	 eax, BYTE PTR tv296[ebp]
  001d6	85 c0		 test	 eax, eax
  001d8	74 59		 je	 SHORT $L51002
  001da	6a 18		 push	 24			; 00000018H
  001dc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001e1	83 c4 04	 add	 esp, 4
  001e4	89 85 40 ff ff
	ff		 mov	 DWORD PTR $T51427[ebp], eax
  001ea	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  001ee	83 bd 40 ff ff
	ff 00		 cmp	 DWORD PTR $T51427[ebp], 0
  001f5	74 17		 je	 SHORT $L51428
  001f7	8d 45 cc	 lea	 eax, DWORD PTR _child$50438[ebp]
  001fa	50		 push	 eax
  001fb	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR $T51427[ebp]
  00201	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  00206	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv192[ebp], eax
  0020c	eb 0a		 jmp	 SHORT $L51429
$L51428:
  0020e	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv192[ebp], 0
$L51429:
  00218	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv192[ebp]
  0021e	89 8d 3c ff ff
	ff		 mov	 DWORD PTR $T51426[ebp], ecx
  00224	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00228	8b 55 20	 mov	 edx, DWORD PTR _filename$[ebp]
  0022b	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T51426[ebp]
  00231	89 02		 mov	 DWORD PTR [edx], eax
$L51002:

; 24   :                 break;

  00233	e9 83 01 00 00	 jmp	 $L50442
$L51008:

; 25   :             case ROLE_SYSTEM_COMBOBOX:
; 26   :                 if (name && EndsWith(name, L"type:")) {

  00238	83 7d c8 00	 cmp	 DWORD PTR _name$50440[ebp], 0
  0023c	0f 84 17 01 00
	00		 je	 $L51011
  00242	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00245	8b cc		 mov	 ecx, esp
  00247	89 a5 44 ff ff
	ff		 mov	 DWORD PTR $T51430[ebp], esp
  0024d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_1M@MCMFDKPF@?$AAt?$AAy?$AAp?$AAe?$AA?3?$AA?$AA@
  00252	e8 00 00 00 00	 call	 ??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
  00257	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv325[ebp], eax
  0025d	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv325[ebp]
  00263	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv302[ebp], eax
  00269	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0026d	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00270	8b cc		 mov	 ecx, esp
  00272	89 a5 48 ff ff
	ff		 mov	 DWORD PTR $T51431[ebp], esp
  00278	8b 55 c8	 mov	 edx, DWORD PTR _name$50440[ebp]
  0027b	52		 push	 edx
  0027c	e8 00 00 00 00	 call	 ??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
  00281	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv306[ebp], eax
  00287	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0028b	e8 00 00 00 00	 call	 ?EndsWith@@YA_NV?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@0@Z ; EndsWith
  00290	83 c4 38	 add	 esp, 56			; 00000038H
  00293	88 85 17 ff ff
	ff		 mov	 BYTE PTR tv303[ebp], al
  00299	0f b6 85 17 ff
	ff ff		 movzx	 eax, BYTE PTR tv303[ebp]
  002a0	85 c0		 test	 eax, eax
  002a2	0f 84 b1 00 00
	00		 je	 $L51011

; 27   : 					for (AccessibleChildIterator items = child.GetChildren(); items.HasNext();) {

  002a8	8d 45 b8	 lea	 eax, DWORD PTR _items$51012[ebp]
  002ab	50		 push	 eax
  002ac	8d 4d cc	 lea	 ecx, DWORD PTR _child$50438[ebp]
  002af	e8 00 00 00 00	 call	 ?GetChildren@AccessibleElement@@QAE?AVAccessibleChildIterator@@XZ ; AccessibleElement::GetChildren
  002b4	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  002b8	8d 4d b8	 lea	 ecx, DWORD PTR _items$51012[ebp]
  002bb	e8 00 00 00 00	 call	 ?HasNext@AccessibleChildIterator@@QAE_NXZ ; AccessibleChildIterator::HasNext
  002c0	0f b6 c0	 movzx	 eax, al
  002c3	85 c0		 test	 eax, eax
  002c5	0f 84 82 00 00
	00		 je	 $L51016

; 28   : 						AccessibleElement item = items.GetNext();

  002cb	8d 45 a0	 lea	 eax, DWORD PTR _item$51017[ebp]
  002ce	50		 push	 eax
  002cf	8d 4d b8	 lea	 ecx, DWORD PTR _items$51012[ebp]
  002d2	e8 00 00 00 00	 call	 ?GetNext@AccessibleChildIterator@@QAE?AVAccessibleElement@@XZ ; AccessibleChildIterator::GetNext
  002d7	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9

; 29   : 						if (item.GetRole() == ROLE_SYSTEM_LISTITEM) *typelist = new AccessibleElement(child);

  002db	8d 4d a0	 lea	 ecx, DWORD PTR _item$51017[ebp]
  002de	e8 00 00 00 00	 call	 ?GetRole@AccessibleElement@@QAEHXZ ; AccessibleElement::GetRole
  002e3	83 f8 22	 cmp	 eax, 34			; 00000022H
  002e6	75 59		 jne	 SHORT $L51019
  002e8	6a 18		 push	 24			; 00000018H
  002ea	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  002ef	83 c4 04	 add	 esp, 4
  002f2	89 85 50 ff ff
	ff		 mov	 DWORD PTR $T51433[ebp], eax
  002f8	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  002fc	83 bd 50 ff ff
	ff 00		 cmp	 DWORD PTR $T51433[ebp], 0
  00303	74 17		 je	 SHORT $L51434
  00305	8d 45 cc	 lea	 eax, DWORD PTR _child$50438[ebp]
  00308	50		 push	 eax
  00309	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR $T51433[ebp]
  0030f	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  00314	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv246[ebp], eax
  0031a	eb 0a		 jmp	 SHORT $L51435
$L51434:
  0031c	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv246[ebp], 0
$L51435:
  00326	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv246[ebp]
  0032c	89 8d 4c ff ff
	ff		 mov	 DWORD PTR $T51432[ebp], ecx
  00332	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00336	8b 55 24	 mov	 edx, DWORD PTR _typelist$[ebp]
  00339	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T51432[ebp]
  0033f	89 02		 mov	 DWORD PTR [edx], eax
$L51019:

; 30   :                         break;

  00341	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00345	8d 4d a0	 lea	 ecx, DWORD PTR _item$51017[ebp]
  00348	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
$L51016:

; 31   :                     }

  0034d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00351	8d 4d b8	 lea	 ecx, DWORD PTR _items$51012[ebp]
  00354	e8 00 00 00 00	 call	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
$L51011:

; 32   :                 }
; 33   :                 if (name) FindElements(child, filename, typelist);

  00359	83 7d c8 00	 cmp	 DWORD PTR _name$50440[ebp], 0
  0035d	74 2a		 je	 SHORT $L51024
  0035f	8b 45 24	 mov	 eax, DWORD PTR _typelist$[ebp]
  00362	50		 push	 eax
  00363	8b 4d 20	 mov	 ecx, DWORD PTR _filename$[ebp]
  00366	51		 push	 ecx
  00367	83 ec 18	 sub	 esp, 24			; 00000018H
  0036a	8b cc		 mov	 ecx, esp
  0036c	89 a5 54 ff ff
	ff		 mov	 DWORD PTR $T51436[ebp], esp
  00372	8d 55 cc	 lea	 edx, DWORD PTR _child$50438[ebp]
  00375	52		 push	 edx
  00376	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  0037b	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv314[ebp], eax
  00381	e8 00 00 00 00	 call	 ?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z ; FindElements
  00386	83 c4 20	 add	 esp, 32			; 00000020H
$L51024:

; 34   :                 break;

  00389	eb 30		 jmp	 SHORT $L50442
$L51026:

; 35   :             case ROLE_SYSTEM_CLIENT:
; 36   :             case ROLE_SYSTEM_DIALOG:
; 37   :             case ROLE_SYSTEM_WINDOW:
; 38   :                 if (name) FindElements(child, filename, typelist);

  0038b	83 7d c8 00	 cmp	 DWORD PTR _name$50440[ebp], 0
  0038f	74 2a		 je	 SHORT $L50442
  00391	8b 45 24	 mov	 eax, DWORD PTR _typelist$[ebp]
  00394	50		 push	 eax
  00395	8b 4d 20	 mov	 ecx, DWORD PTR _filename$[ebp]
  00398	51		 push	 ecx
  00399	83 ec 18	 sub	 esp, 24			; 00000018H
  0039c	8b cc		 mov	 ecx, esp
  0039e	89 a5 58 ff ff
	ff		 mov	 DWORD PTR $T51437[ebp], esp
  003a4	8d 55 cc	 lea	 edx, DWORD PTR _child$50438[ebp]
  003a7	52		 push	 edx
  003a8	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  003ad	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv318[ebp], eax
  003b3	e8 00 00 00 00	 call	 ?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z ; FindElements
  003b8	83 c4 20	 add	 esp, 32			; 00000020H
$L50442:

; 39   :                 break;
; 40   :         }
; 41   :         if (*filename && *typelist) return true;

  003bb	8b 45 20	 mov	 eax, DWORD PTR _filename$[ebp]
  003be	83 38 00	 cmp	 DWORD PTR [eax], 0
  003c1	74 3e		 je	 SHORT $L51029
  003c3	8b 45 24	 mov	 eax, DWORD PTR _typelist$[ebp]
  003c6	83 38 00	 cmp	 DWORD PTR [eax], 0
  003c9	74 36		 je	 SHORT $L51029
  003cb	c6 85 5e ff ff
	ff 01		 mov	 BYTE PTR $T51438[ebp], 1
  003d2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  003d6	8d 4d cc	 lea	 ecx, DWORD PTR _child$50438[ebp]
  003d9	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  003de	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003e2	8d 4d e4	 lea	 ecx, DWORD PTR _children$50433[ebp]
  003e5	e8 00 00 00 00	 call	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
  003ea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003f1	8d 4d 08	 lea	 ecx, DWORD PTR _element$[ebp]
  003f4	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  003f9	8a 85 5e ff ff
	ff		 mov	 al, BYTE PTR $T51438[ebp]
  003ff	eb 39		 jmp	 SHORT $L50432
$L51029:

; 42   :     }

  00401	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00405	8d 4d cc	 lea	 ecx, DWORD PTR _child$50438[ebp]
  00408	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  0040d	e9 26 fc ff ff	 jmp	 $L50436
$L50437:
  00412	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00416	8d 4d e4	 lea	 ecx, DWORD PTR _children$50433[ebp]
  00419	e8 00 00 00 00	 call	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator

; 43   :     return false;

  0041e	c6 85 5f ff ff
	ff 00		 mov	 BYTE PTR $T51439[ebp], 0
  00425	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0042c	8d 4d 08	 lea	 ecx, DWORD PTR _element$[ebp]
  0042f	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  00434	8a 85 5f ff ff
	ff		 mov	 al, BYTE PTR $T51439[ebp]
$L50432:

; 44   : }

  0043a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0043d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00444	5f		 pop	 edi
  00445	5e		 pop	 esi
  00446	5b		 pop	 ebx
  00447	8b e5		 mov	 esp, ebp
  00449	5d		 pop	 ebp
  0044a	c3		 ret	 0
$L51463:
  0044b	00 00 00 00	 DD	 $L51026
  0044f	00 00 00 00	 DD	 $L50445
  00453	00 00 00 00	 DD	 $L50999
  00457	00 00 00 00	 DD	 $L51008
  0045b	00 00 00 00	 DD	 $L50442
$L51460:
  0045f	00		 DB	 0
  00460	00		 DB	 0
  00461	04		 DB	 4
  00462	04		 DB	 4
  00463	04		 DB	 4
  00464	04		 DB	 4
  00465	04		 DB	 4
  00466	04		 DB	 4
  00467	04		 DB	 4
  00468	00		 DB	 0
  00469	04		 DB	 4
  0046a	04		 DB	 4
  0046b	04		 DB	 4
  0046c	04		 DB	 4
  0046d	04		 DB	 4
  0046e	04		 DB	 4
  0046f	04		 DB	 4
  00470	04		 DB	 4
  00471	04		 DB	 4
  00472	04		 DB	 4
  00473	04		 DB	 4
  00474	04		 DB	 4
  00475	04		 DB	 4
  00476	04		 DB	 4
  00477	01		 DB	 1
  00478	04		 DB	 4
  00479	04		 DB	 4
  0047a	04		 DB	 4
  0047b	04		 DB	 4
  0047c	04		 DB	 4
  0047d	04		 DB	 4
  0047e	04		 DB	 4
  0047f	04		 DB	 4
  00480	02		 DB	 2
  00481	04		 DB	 4
  00482	04		 DB	 4
  00483	04		 DB	 4
  00484	03		 DB	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _element$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$1:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR _children$50433[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$2:
  00010	8d 4d cc	 lea	 ecx, DWORD PTR _child$50438[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$3:
  00018	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR $T51418[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::~basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$5:
  00023	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR $T51421[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	c3		 ret	 0
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$6:
  00031	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR $T51424[ebp]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::~basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$8:
  0003c	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR $T51427[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00048	59		 pop	 ecx
  00049	c3		 ret	 0
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$9:
  0004a	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR $T51430[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::~basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$11:
  00055	8d 4d b8	 lea	 ecx, DWORD PTR _items$51012[ebp]
  00058	e9 00 00 00 00	 jmp	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$12:
  0005d	8d 4d a0	 lea	 ecx, DWORD PTR _item$51017[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
__unwindfunclet$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z$13:
  00065	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR $T51433[ebp]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00071	59		 pop	 ecx
  00072	c3		 ret	 0
__ehhandler$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z:
  00073	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z
  00078	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z ENDP	; FindElements
EXTRN	?GetState@AccessibleElement@@QAEHXZ:NEAR	; AccessibleElement::GetState
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetSelection@@YAHVAccessibleElement@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSelection@@YAHVAccessibleElement@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetSelection@@YAHVAccessibleElement@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetSelection@@YAHVAccessibleElement@@@Z$2
__ehfuncinfo$?GetSelection@@YAHVAccessibleElement@@@Z DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$?GetSelection@@YAHVAccessibleElement@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /ZI
xdata$x	ENDS
;	COMDAT ?GetSelection@@YAHVAccessibleElement@@@Z
_TEXT	SEGMENT
$T51470 = -132						; size = 4
$T51471 = -128						; size = 4
_item$51042 = -60					; size = 24
_i$51038 = -36						; size = 4
_children$ = -32					; size = 16
_count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_list$ = 8						; size = 24
?GetSelection@@YAHVAccessibleElement@@@Z PROC NEAR	; GetSelection, COMDAT

; 47   : static int GetSelection(AccessibleElement list) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSelection@@YAHVAccessibleElement@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 78	 sub	 esp, 120		; 00000078H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 48   : 	int count = list.CountChildren();

  00025	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  00028	e8 00 00 00 00	 call	 ?CountChildren@AccessibleElement@@QAEHXZ ; AccessibleElement::CountChildren
  0002d	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax

; 49   : 	AccessibleChildIterator children = list.GetChildren();

  00030	8d 45 e0	 lea	 eax, DWORD PTR _children$[ebp]
  00033	50		 push	 eax
  00034	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  00037	e8 00 00 00 00	 call	 ?GetChildren@AccessibleElement@@QAE?AVAccessibleChildIterator@@XZ ; AccessibleElement::GetChildren
  0003c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 50   : 	for (int i = 0; i < count; i++) {

  00040	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$51038[ebp], 0
  00047	eb 09		 jmp	 SHORT $L51039
$L51040:
  00049	8b 45 dc	 mov	 eax, DWORD PTR _i$51038[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 dc	 mov	 DWORD PTR _i$51038[ebp], eax
$L51039:
  00052	8b 45 dc	 mov	 eax, DWORD PTR _i$51038[ebp]
  00055	3b 45 f0	 cmp	 eax, DWORD PTR _count$[ebp]
  00058	7d 65		 jge	 SHORT $L51041

; 51   : 		AccessibleElement item = children.GetNext();

  0005a	8d 45 c4	 lea	 eax, DWORD PTR _item$51042[ebp]
  0005d	50		 push	 eax
  0005e	8d 4d e0	 lea	 ecx, DWORD PTR _children$[ebp]
  00061	e8 00 00 00 00	 call	 ?GetNext@AccessibleChildIterator@@QAE?AVAccessibleElement@@XZ ; AccessibleChildIterator::GetNext
  00066	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 52   : 		// In common file dialogs, the selected item has the STATE_SYSTEM_SELECTED flag.
; 53   : 		// In Office file dialogs, the selected item has the STATE_SYSTEM_HOTTRACKED flag.
; 54   :         if (item.GetState() & (STATE_SYSTEM_SELECTED | STATE_SYSTEM_HOTTRACKED)) return i;

  0006a	8d 4d c4	 lea	 ecx, DWORD PTR _item$51042[ebp]
  0006d	e8 00 00 00 00	 call	 ?GetState@AccessibleElement@@QAEHXZ ; AccessibleElement::GetState
  00072	25 82 00 00 00	 and	 eax, 130		; 00000082H
  00077	74 38		 je	 SHORT $L51044
  00079	8b 45 dc	 mov	 eax, DWORD PTR _i$51038[ebp]
  0007c	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T51470[ebp], eax
  00082	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00086	8d 4d c4	 lea	 ecx, DWORD PTR _item$51042[ebp]
  00089	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  0008e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00092	8d 4d e0	 lea	 ecx, DWORD PTR _children$[ebp]
  00095	e8 00 00 00 00	 call	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
  0009a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a1	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  000a4	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  000a9	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T51470[ebp]
  000af	eb 33		 jmp	 SHORT $L51034
$L51044:

; 55   : 	}

  000b1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000b5	8d 4d c4	 lea	 ecx, DWORD PTR _item$51042[ebp]
  000b8	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  000bd	eb 8a		 jmp	 SHORT $L51040
$L51041:

; 56   : 	return -1;

  000bf	c7 45 80 ff ff
	ff ff		 mov	 DWORD PTR $T51471[ebp], -1
  000c6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000ca	8d 4d e0	 lea	 ecx, DWORD PTR _children$[ebp]
  000cd	e8 00 00 00 00	 call	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
  000d2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d9	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  000dc	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  000e1	8b 45 80	 mov	 eax, DWORD PTR $T51471[ebp]
$L51034:

; 57   : }

  000e4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ee	5f		 pop	 edi
  000ef	5e		 pop	 esi
  000f0	5b		 pop	 ebx
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSelection@@YAHVAccessibleElement@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
__unwindfunclet$?GetSelection@@YAHVAccessibleElement@@@Z$1:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR _children$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
__unwindfunclet$?GetSelection@@YAHVAccessibleElement@@@Z$2:
  00010	8d 4d c4	 lea	 ecx, DWORD PTR _item$51042[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
__ehhandler$?GetSelection@@YAHVAccessibleElement@@@Z:
  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?GetSelection@@YAHVAccessibleElement@@@Z
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetSelection@@YAHVAccessibleElement@@@Z ENDP		; GetSelection
; Function compile flags: /Odt /ZI
;	COMDAT ??_GAccessibleElement@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAccessibleElement@@QAEPAXI@Z PROC NEAR		; AccessibleElement::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $L51110
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$L51110:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_GAccessibleElement@@QAEPAXI@Z ENDP			; AccessibleElement::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	_FileDialogSubmit
PUBLIC	??_C@_0L@GEHIOJLB@Snake?5List?$AA@		; `string'
EXTRN	?Focus@AccessibleElement@@QAEXXZ:NEAR		; AccessibleElement::Focus
EXTRN	__imp__ShowWindow@8:NEAR
EXTRN	__imp__SetForegroundWindow@4:NEAR
EXTRN	__imp__GetDlgItem@8:NEAR
EXTRN	__imp__SetWindowTextW@8:NEAR
EXTRN	__imp__SetFocus@4:NEAR
EXTRN	__imp__FindWindowExA@16:NEAR
EXTRN	_BlockInput@4:NEAR
EXTRN	?fix@Message@@QAEXPAPBG@Z:NEAR			; Message::fix
;	COMDAT ??_C@_0L@GEHIOJLB@Snake?5List?$AA@
CONST	SEGMENT
??_C@_0L@GEHIOJLB@Snake?5List?$AA@ DB 'Snake List', 00H	; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT _FileDialogSubmit
_TEXT	SEGMENT
$T51485 = -148						; size = 4
$T51486 = -144						; size = 4
$T51487 = -140						; size = 4
$T51488 = -136						; size = 4
$T51489 = -132						; size = 4
_textfield$51129 = -64					; size = 4
_textfield$51125 = -60					; size = 4
_typelist$ = -56					; size = 4
_filename$ = -52					; size = 4
_dialog$ = -48						; size = 24
_submit$ = -24						; size = 4
_request$ = -20						; size = 20
_buffer$ = 8						; size = 4
_bufsize$ = 12						; size = 4
_FileDialogSubmit PROC NEAR				; COMDAT

; 138  : EXPORT size_t __cdecl FileDialogSubmit(BYTE* buffer, size_t bufsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 139  : 	Message request(buffer, bufsize);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _bufsize$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00013	51		 push	 ecx
  00014	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  00017	e8 00 00 00 00	 call	 ??0Message@@QAE@PBEI@Z	; Message::Message

; 140  : 	FILEDIALOGSUBMIT* submit;
; 141  : 	request.cast(&submit, sizeof(*submit));

  0001c	6a 10		 push	 16			; 00000010H
  0001e	8d 45 e8	 lea	 eax, DWORD PTR _submit$[ebp]
  00021	50		 push	 eax
  00022	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  00025	e8 00 00 00 00	 call	 ?cast@Message@@QAEXPAXI@Z ; Message::cast

; 142  : 	request.fix(&(submit->path));

  0002a	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  00034	e8 00 00 00 00	 call	 ?fix@Message@@QAEXPAPBG@Z ; Message::fix

; 143  : 
; 144  : 	// Find the relevant elements of the file dialog.
; 145  : 	AccessibleElement dialog(submit->window);

  00039	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	51		 push	 ecx
  0003f	8d 4d d0	 lea	 ecx, DWORD PTR _dialog$[ebp]
  00042	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@PAUHWND__@@@Z ; AccessibleElement::AccessibleElement

; 146  : 	AccessibleElement* filename = NULL;

  00047	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _filename$[ebp], 0

; 147  : 	AccessibleElement* typelist = NULL;

  0004e	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _typelist$[ebp], 0

; 148  : 	if (!FindElements(dialog, &filename, &typelist)) return 0;

  00055	8d 45 c8	 lea	 eax, DWORD PTR _typelist$[ebp]
  00058	50		 push	 eax
  00059	8d 4d cc	 lea	 ecx, DWORD PTR _filename$[ebp]
  0005c	51		 push	 ecx
  0005d	83 ec 18	 sub	 esp, 24			; 00000018H
  00060	8b cc		 mov	 ecx, esp
  00062	89 a5 6c ff ff
	ff		 mov	 DWORD PTR $T51485[ebp], esp
  00068	8d 55 d0	 lea	 edx, DWORD PTR _dialog$[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  00071	e8 00 00 00 00	 call	 ?FindElements@@YA_NVAccessibleElement@@PAPAV1@1@Z ; FindElements
  00076	83 c4 20	 add	 esp, 32			; 00000020H
  00079	0f b6 c0	 movzx	 eax, al
  0007c	85 c0		 test	 eax, eax
  0007e	75 25		 jne	 SHORT $L51121
  00080	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T51486[ebp], 0
  0008a	8d 4d d0	 lea	 ecx, DWORD PTR _dialog$[ebp]
  0008d	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  00092	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  00095	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  0009a	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T51486[ebp]
  000a0	e9 7c 01 00 00	 jmp	 $L51114
$L51121:

; 149  : 
; 150  : 	// Prevent other mouse or keyboard input from interfering with our
; 151  : 	// sequence of synthesized keypresses.
; 152  : 	BlockInput(true);

  000a5	6a 01		 push	 1
  000a7	e8 00 00 00 00	 call	 _BlockInput@4

; 153  : 
; 154  : 	// Bring up the window somewhere inconspicuous.
; 155  :     //SetWindowPos(submit->window, NULL, 5000, 5000, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
; 156  : 	ShowWindow(submit->window, SW_SHOW);

  000ac	6a 05		 push	 5
  000ae	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  000b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b3	51		 push	 ecx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8

; 157  : 	SetForegroundWindow(submit->window);

  000ba	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  000bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bf	51		 push	 ecx
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetForegroundWindow@4

; 158  : 
; 159  : 	// Only Office file dialogs contain a "Snake List" control.
; 160  : 	if (FindWindowEx(submit->window, NULL, "Snake List", NULL)) {

  000c6	6a 00		 push	 0
  000c8	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@GEHIOJLB@Snake?5List?$AA@
  000cd	6a 00		 push	 0
  000cf	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  000d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d4	51		 push	 ecx
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindWindowExA@16
  000db	85 c0		 test	 eax, eax
  000dd	0f 84 8b 00 00
	00		 je	 $L51123

; 161  : 		// In Office file dialogs, the filename field has control ID 54.
; 162  : 		HWND textfield = GetDlgItem(submit->window, 54);

  000e3	6a 36		 push	 54			; 00000036H
  000e5	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  000e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ea	51		 push	 ecx
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  000f1	89 45 c4	 mov	 DWORD PTR _textfield$51125[ebp], eax

; 163  : 
; 164  :         // For Office file dialogs, we have to set the file type first.  If we
; 165  :         // set the file name first, Office will fix its extension to match the
; 166  :         // currently selected file type, which may not be the desired file type.
; 167  : 		// To make the file type setting take effect, Return must be pressed on
; 168  : 		// the file type list.
; 169  :         typelist->Focus();

  000f4	8b 4d c8	 mov	 ecx, DWORD PTR _typelist$[ebp]
  000f7	e8 00 00 00 00	 call	 ?Focus@AccessibleElement@@QAEXXZ ; AccessibleElement::Focus

; 170  : 		SendKey(VK_DOWN);

  000fc	6a 28		 push	 40			; 00000028H
  000fe	e8 00 00 00 00	 call	 ?SendKey@@YAXG@Z	; SendKey
  00103	83 c4 04	 add	 esp, 4

; 171  :         SetSelection(*typelist, submit->filetype - 1);

  00106	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  00109	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0010c	83 e9 01	 sub	 ecx, 1
  0010f	51		 push	 ecx
  00110	83 ec 18	 sub	 esp, 24			; 00000018H
  00113	8b cc		 mov	 ecx, esp
  00115	89 a5 74 ff ff
	ff		 mov	 DWORD PTR $T51487[ebp], esp
  0011b	8b 55 c8	 mov	 edx, DWORD PTR _typelist$[ebp]
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  00124	e8 00 00 00 00	 call	 ?SetSelection@@YAXVAccessibleElement@@H@Z ; SetSelection
  00129	83 c4 1c	 add	 esp, 28			; 0000001cH

; 172  : 		SendKey(VK_RETURN);

  0012c	6a 0d		 push	 13			; 0000000dH
  0012e	e8 00 00 00 00	 call	 ?SendKey@@YAXG@Z	; SendKey
  00133	83 c4 04	 add	 esp, 4

; 173  : 
; 174  : 		// Now put the path into the filename field.  Its extension will be
; 175  : 		// automatically fixed up when the dialog is submitted.
; 176  : 		SetWindowTextW(textfield, submit->path);

  00136	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  00139	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013c	51		 push	 ecx
  0013d	8b 55 c4	 mov	 edx, DWORD PTR _textfield$51125[ebp]
  00140	52		 push	 edx
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 177  : 		if (!submit->cancel) {

  00147	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  0014a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0014e	75 1c		 jne	 SHORT $L51127

; 178  : 			// The text field's contents have to be changed by a keypress
; 179  : 			// in order to take effect.
; 180  : 	        filename->Focus();

  00150	8b 4d cc	 mov	 ecx, DWORD PTR _filename$[ebp]
  00153	e8 00 00 00 00	 call	 ?Focus@AccessibleElement@@QAEXXZ ; AccessibleElement::Focus

; 181  : 			SendKey(VK_END);

  00158	6a 23		 push	 35			; 00000023H
  0015a	e8 00 00 00 00	 call	 ?SendKey@@YAXG@Z	; SendKey
  0015f	83 c4 04	 add	 esp, 4

; 182  : 			SendKey(VK_SPACE);

  00162	6a 20		 push	 32			; 00000020H
  00164	e8 00 00 00 00	 call	 ?SendKey@@YAXG@Z	; SendKey
  00169	83 c4 04	 add	 esp, 4
$L51127:

; 183  : 		}
; 184  :     } else {

  0016c	eb 73		 jmp	 SHORT $L51128
$L51123:

; 185  :     	// In common file dialogs, the filename field has control ID 1148.
; 186  : 		HWND textfield = GetDlgItem(submit->window, 1148);

  0016e	68 7c 04 00 00	 push	 1148			; 0000047cH
  00173	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  00176	8b 08		 mov	 ecx, DWORD PTR [eax]
  00178	51		 push	 ecx
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDlgItem@8
  0017f	89 45 c0	 mov	 DWORD PTR _textfield$51129[ebp], eax

; 187  : 
; 188  : 	    // For common file dialogs, we have to set the file name first, so that
; 189  :         // setting the file type can fix up the file name extension as necessary.
; 190  : 		SetWindowTextW(textfield, submit->path);

  00182	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  00185	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00188	51		 push	 ecx
  00189	8b 55 c0	 mov	 edx, DWORD PTR _textfield$51129[ebp]
  0018c	52		 push	 edx
  0018d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowTextW@8

; 191  :     
; 192  :         // To make the file type setting take effect, Return has to be pressed
; 193  :         // on the file type list, and it must cause the selection to change.
; 194  :         SetFocus(textfield);

  00193	8b 45 c0	 mov	 eax, DWORD PTR _textfield$51129[ebp]
  00196	50		 push	 eax
  00197	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4

; 195  : 		SendKey(VK_TAB);

  0019d	6a 09		 push	 9
  0019f	e8 00 00 00 00	 call	 ?SendKey@@YAXG@Z	; SendKey
  001a4	83 c4 04	 add	 esp, 4

; 196  : 		SendKey(VK_DOWN);

  001a7	6a 28		 push	 40			; 00000028H
  001a9	e8 00 00 00 00	 call	 ?SendKey@@YAXG@Z	; SendKey
  001ae	83 c4 04	 add	 esp, 4

; 197  :         SetSelection(*typelist, submit->filetype - 1);

  001b1	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  001b4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001b7	83 e9 01	 sub	 ecx, 1
  001ba	51		 push	 ecx
  001bb	83 ec 18	 sub	 esp, 24			; 00000018H
  001be	8b cc		 mov	 ecx, esp
  001c0	89 a5 78 ff ff
	ff		 mov	 DWORD PTR $T51488[ebp], esp
  001c6	8b 55 c8	 mov	 edx, DWORD PTR _typelist$[ebp]
  001c9	52		 push	 edx
  001ca	e8 00 00 00 00	 call	 ??0AccessibleElement@@QAE@AAV0@@Z ; AccessibleElement::AccessibleElement
  001cf	e8 00 00 00 00	 call	 ?SetSelection@@YAXVAccessibleElement@@H@Z ; SetSelection
  001d4	83 c4 1c	 add	 esp, 28			; 0000001cH

; 198  :         SendKey(VK_RETURN);

  001d7	6a 0d		 push	 13			; 0000000dH
  001d9	e8 00 00 00 00	 call	 ?SendKey@@YAXG@Z	; SendKey
  001de	83 c4 04	 add	 esp, 4
$L51128:

; 199  :     }
; 200  : 
; 201  : 	// Submit or cancel the dialog.
; 202  : 	SendKey(submit->cancel ? VK_ESCAPE : VK_RETURN);

  001e1	8b 45 e8	 mov	 eax, DWORD PTR _submit$[ebp]
  001e4	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001e7	f7 d9		 neg	 ecx
  001e9	1b c9		 sbb	 ecx, ecx
  001eb	83 e1 0e	 and	 ecx, 14			; 0000000eH
  001ee	83 c1 0d	 add	 ecx, 13			; 0000000dH
  001f1	51		 push	 ecx
  001f2	e8 00 00 00 00	 call	 ?SendKey@@YAXG@Z	; SendKey
  001f7	83 c4 04	 add	 esp, 4

; 203  : 	BlockInput(false);

  001fa	6a 00		 push	 0
  001fc	e8 00 00 00 00	 call	 _BlockInput@4

; 204  : 	return 0;

  00201	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T51489[ebp], 0
  0020b	8d 4d d0	 lea	 ecx, DWORD PTR _dialog$[ebp]
  0020e	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  00213	8d 4d ec	 lea	 ecx, DWORD PTR _request$[ebp]
  00216	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  0021b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T51489[ebp]
$L51114:

; 205  : }

  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5b		 pop	 ebx
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
_FileDialogSubmit ENDP
_TEXT	ENDS
EXTRN	?Select@AccessibleElement@@QAEXXZ:NEAR		; AccessibleElement::Select
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetSelection@@YAXVAccessibleElement@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetSelection@@YAXVAccessibleElement@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetSelection@@YAXVAccessibleElement@@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SetSelection@@YAXVAccessibleElement@@H@Z$2
__ehfuncinfo$?SetSelection@@YAXVAccessibleElement@@H@Z DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$?SetSelection@@YAXVAccessibleElement@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /ZI
xdata$x	ENDS
;	COMDAT ?SetSelection@@YAXVAccessibleElement@@H@Z
_TEXT	SEGMENT
_item$51058 = -60					; size = 24
_i$51054 = -36						; size = 4
_children$ = -32					; size = 16
_count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_list$ = 8						; size = 24
_index$ = 32						; size = 4
?SetSelection@@YAXVAccessibleElement@@H@Z PROC NEAR	; SetSelection, COMDAT

; 60   : static void SetSelection(AccessibleElement list, int index) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetSelection@@YAXVAccessibleElement@@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 70	 sub	 esp, 112		; 00000070H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 61   : 	int count = list.CountChildren();

  00025	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  00028	e8 00 00 00 00	 call	 ?CountChildren@AccessibleElement@@QAEHXZ ; AccessibleElement::CountChildren
  0002d	89 45 f0	 mov	 DWORD PTR _count$[ebp], eax

; 62   : 	AccessibleChildIterator children = list.GetChildren();

  00030	8d 45 e0	 lea	 eax, DWORD PTR _children$[ebp]
  00033	50		 push	 eax
  00034	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  00037	e8 00 00 00 00	 call	 ?GetChildren@AccessibleElement@@QAE?AVAccessibleChildIterator@@XZ ; AccessibleElement::GetChildren
  0003c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 63   : 	for (int i = 0; i < count; i++) {

  00040	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _i$51054[ebp], 0
  00047	eb 09		 jmp	 SHORT $L51055
$L51056:
  00049	8b 45 dc	 mov	 eax, DWORD PTR _i$51054[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 dc	 mov	 DWORD PTR _i$51054[ebp], eax
$L51055:
  00052	8b 45 dc	 mov	 eax, DWORD PTR _i$51054[ebp]
  00055	3b 45 f0	 cmp	 eax, DWORD PTR _count$[ebp]
  00058	7d 2e		 jge	 SHORT $L51057

; 64   : 		AccessibleElement item = children.GetNext();

  0005a	8d 45 c4	 lea	 eax, DWORD PTR _item$51058[ebp]
  0005d	50		 push	 eax
  0005e	8d 4d e0	 lea	 ecx, DWORD PTR _children$[ebp]
  00061	e8 00 00 00 00	 call	 ?GetNext@AccessibleChildIterator@@QAE?AVAccessibleElement@@XZ ; AccessibleChildIterator::GetNext
  00066	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 65   : 		if (i == index) item.Select();

  0006a	8b 45 dc	 mov	 eax, DWORD PTR _i$51054[ebp]
  0006d	3b 45 20	 cmp	 eax, DWORD PTR _index$[ebp]
  00070	75 08		 jne	 SHORT $L51060
  00072	8d 4d c4	 lea	 ecx, DWORD PTR _item$51058[ebp]
  00075	e8 00 00 00 00	 call	 ?Select@AccessibleElement@@QAEXXZ ; AccessibleElement::Select
$L51060:

; 66   : 	}

  0007a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0007e	8d 4d c4	 lea	 ecx, DWORD PTR _item$51058[ebp]
  00081	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  00086	eb c1		 jmp	 SHORT $L51056
$L51057:

; 67   : }

  00088	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008c	8d 4d e0	 lea	 ecx, DWORD PTR _children$[ebp]
  0008f	e8 00 00 00 00	 call	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
  00094	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009b	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  0009e	e8 00 00 00 00	 call	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetSelection@@YAXVAccessibleElement@@H@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _list$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
__unwindfunclet$?SetSelection@@YAXVAccessibleElement@@H@Z$1:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR _children$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1AccessibleChildIterator@@QAE@XZ ; AccessibleChildIterator::~AccessibleChildIterator
__unwindfunclet$?SetSelection@@YAXVAccessibleElement@@H@Z$2:
  00010	8d 4d c4	 lea	 ecx, DWORD PTR _item$51058[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1AccessibleElement@@QAE@XZ ; AccessibleElement::~AccessibleElement
__ehhandler$?SetSelection@@YAXVAccessibleElement@@H@Z:
  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?SetSelection@@YAXVAccessibleElement@@H@Z
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SetSelection@@YAXVAccessibleElement@@H@Z ENDP		; SetSelection
EXTRN	__imp__WaitForInputIdle@8:NEAR
EXTRN	__imp__GetCurrentProcess@0:NEAR
EXTRN	__imp__SendInput@12:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT ?SendKey@@YAXG@Z
_TEXT	SEGMENT
_inputs$ = -56						; size = 56
_virtkey$ = 8						; size = 2
?SendKey@@YAXG@Z PROC NEAR				; SendKey, COMDAT

; 70   : static void SendKey(WORD virtkey) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 71   : 	INPUT inputs[2];
; 72   : 	inputs[0].type = INPUT_KEYBOARD;

  00009	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR _inputs$[ebp], 1

; 73   : 	inputs[0].ki.wVk = virtkey;

  00010	66 8b 45 08	 mov	 ax, WORD PTR _virtkey$[ebp]
  00014	66 89 45 cc	 mov	 WORD PTR _inputs$[ebp+4], ax

; 74   : 	inputs[0].ki.wScan = 0;

  00018	66 c7 45 ce 00
	00		 mov	 WORD PTR _inputs$[ebp+6], 0

; 75   : 	inputs[0].ki.dwFlags = 0;

  0001e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _inputs$[ebp+8], 0

; 76   : 	inputs[0].ki.time = 0;

  00025	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _inputs$[ebp+12], 0

; 77   : 	inputs[0].ki.dwExtraInfo = 0;

  0002c	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _inputs$[ebp+16], 0

; 78   : 	inputs[1] = inputs[0];

  00033	b9 07 00 00 00	 mov	 ecx, 7
  00038	8d 75 c8	 lea	 esi, DWORD PTR _inputs$[ebp]
  0003b	8d 7d e4	 lea	 edi, DWORD PTR _inputs$[ebp+28]
  0003e	f3 a5		 rep movsd

; 79   : 	inputs[1].ki.dwFlags = KEYEVENTF_KEYUP;

  00040	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR _inputs$[ebp+36], 2

; 80   : 	SendInput(2, inputs, sizeof(*inputs));

  00047	6a 1c		 push	 28			; 0000001cH
  00049	8d 45 c8	 lea	 eax, DWORD PTR _inputs$[ebp]
  0004c	50		 push	 eax
  0004d	6a 02		 push	 2
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SendInput@12

; 81   : 	WaitForInputIdle(GetCurrentProcess(), INFINITE);

  00055	6a ff		 push	 -1
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcess@0
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForInputIdle@8

; 82   : }

  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5b		 pop	 ebx
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?SendKey@@YAXG@Z ENDP					; SendKey
_TEXT	ENDS
PUBLIC	??0?$allocator@G@std@@QAE@XZ			; std::allocator<unsigned short>::allocator<unsigned short>
PUBLIC	??0?$_String_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ; std::_String_val<unsigned short,std::allocator<unsigned short> >::_String_val<unsigned short,std::allocator<unsigned short> >
PUBLIC	?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign
PUBLIC	?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Tidy
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 360  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@G@std@@QAE@XZ ; std::allocator<unsigned short>::allocator<unsigned short>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_String_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ; std::_String_val<unsigned short,std::allocator<unsigned short> >::_String_val<unsigned short,std::allocator<unsigned short> >

; 361  : 		_Tidy();

  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Tidy

; 362  : 		assign(_Ptr);

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign

; 363  : 		}

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBG@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::~basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

  0000c	6a 00		 push	 0
  0000e	6a 01		 push	 1
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Tidy

; 458  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::~basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBGI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign
PUBLIC	?length@?$char_traits@G@std@@SAIPBG@Z		; std::char_traits<unsigned short>::length
; Function compile flags: /Odt /ZI
;	COMDAT ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBG@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?length@?$char_traits@G@std@@SAIPBG@Z ; std::char_traits<unsigned short>::length
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBGI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign

; 623  : 		}

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBG@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign
_TEXT	ENDS
EXTRN	_wcslen:NEAR
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?length@?$char_traits@G@std@@SAIPBG@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@G@std@@SAIPBG@Z PROC NEAR		; std::char_traits<unsigned short>::length, COMDAT

; 264  : 		{	// find length of null-terminated sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 265  : 		return (::wcslen(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _wcslen
  00012	83 c4 04	 add	 esp, 4

; 266  : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?length@?$char_traits@G@std@@SAIPBG@Z ENDP		; std::char_traits<unsigned short>::length
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@G@std@@QAEXPAGI@Z	; std::allocator<unsigned short>::deallocate
PUBLIC	?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos
PUBLIC	?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z	; std::char_traits<unsigned short>::copy
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$51228 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  00010	85 c0		 test	 eax, eax
  00012	75 02		 jne	 SHORT $L51225

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

  00014	eb 45		 jmp	 SHORT $L51226
$L51225:
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 78 18 08	 cmp	 DWORD PTR [eax+24], 8
  0001d	72 3c		 jb	 SHORT $L51226

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00025	89 4d f8	 mov	 DWORD PTR __Ptr$51228[ebp], ecx

; 1515 : 			if (0 < _Newsize)

  00028	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0002c	76 17		 jbe	 SHORT $L51229

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00031	50		 push	 eax
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$51228[ebp]
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	83 c2 04	 add	 edx, 4
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z ; std::char_traits<unsigned short>::copy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$L51229:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004b	83 c1 01	 add	 ecx, 1
  0004e	51		 push	 ecx
  0004f	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$51228[ebp]
  00052	52		 push	 edx
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?deallocate@?$allocator@G@std@@QAEXPAGI@Z ; std::allocator<unsigned short>::deallocate
$L51226:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 40 18 07 00
	00 00		 mov	 DWORD PTR [eax+24], 7

; 1520 : 		_Eos(_Newsize);

  00065	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos

; 1521 : 		}

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Tidy
_TEXT	ENDS
PUBLIC	_wmemcpy
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z PROC NEAR	; std::char_traits<unsigned short>::copy, COMDAT

; 270  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 271  : 		return (::wmemcpy(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _wmemcpy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 272  : 		}

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z ENDP		; std::char_traits<unsigned short>::copy
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC NEAR					; COMDAT

; 792  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 793  :             return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00009	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  0000c	d1 e0		 shl	 eax, 1
  0000e	50		 push	 eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _memcpy
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 794  :         }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
PUBLIC	??0?$allocator@G@std@@QAE@ABV01@@Z		; std::allocator<unsigned short>::allocator<unsigned short>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$_String_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z PROC NEAR ; std::_String_val<unsigned short,std::allocator<unsigned short> >::_String_val<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$allocator@G@std@@QAE@ABV01@@Z ; std::allocator<unsigned short>::allocator<unsigned short>

; 35   : 		}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0?$_String_val@GV?$allocator@G@std@@@std@@IAE@V?$allocator@G@1@@Z ENDP ; std::_String_val<unsigned short,std::allocator<unsigned short> >::_String_val<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@G@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@G@std@@QAE@XZ PROC NEAR			; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@G@std@@QAE@XZ ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign
PUBLIC	?_Grow@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NI_N@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Grow
PUBLIC	?_Inside@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NPBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Inside
PUBLIC	?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBGI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBGI@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 609  : 		if (_Inside(_Ptr))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NPBG@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Inside
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	74 22		 je	 SHORT $L51236

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Num$[ebp]
  00022	50		 push	 eax
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	2b c8		 sub	 ecx, eax
  00030	d1 f9		 sar	 ecx, 1
  00032	51		 push	 ecx
  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	52		 push	 edx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign
  0003f	eb 3d		 jmp	 SHORT $L51235
$L51236:

; 611  : 
; 612  : 		if (_Grow(_Num))

  00041	6a 00		 push	 0
  00043	8b 45 0c	 mov	 eax, DWORD PTR __Num$[ebp]
  00046	50		 push	 eax
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NI_N@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Grow
  0004f	0f b6 c8	 movzx	 ecx, al
  00052	85 c9		 test	 ecx, ecx
  00054	74 25		 je	 SHORT $L51237

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

  00056	8b 45 0c	 mov	 eax, DWORD PTR __Num$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z ; std::char_traits<unsigned short>::copy
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 615  : 			_Eos(_Num);

  0006f	8b 45 0c	 mov	 eax, DWORD PTR __Num$[ebp]
  00072	50		 push	 eax
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos
$L51237:

; 616  : 			}
; 617  : 		return (*this);

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$L51235:

; 618  : 		}

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 08 00	 ret	 8
?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBGI@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@G@std@@SAXAAGABG@Z	; std::char_traits<unsigned short>::assign
; Function compile flags: /Odt /ZI
;	COMDAT ?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T51526 = -70						; size = 2
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  0000c	66 c7 45 ba 00
	00		 mov	 WORD PTR $T51526[ebp], 0
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00018	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0001b	8d 55 ba	 lea	 edx, DWORD PTR $T51526[ebp]
  0001e	52		 push	 edx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0002a	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ?assign@?$char_traits@G@std@@SAXAAGABG@Z ; std::char_traits<unsigned short>::assign
  00033	83 c4 08	 add	 esp, 8

; 1476 : 		}

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@G@std@@SAXAAGABG@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@G@std@@SAXAAGABG@Z PROC NEAR	; std::char_traits<unsigned short>::assign, COMDAT

; 243  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 244  : 		_Left = _Right;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00012	66 89 10	 mov	 WORD PTR [eax], dx

; 245  : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?assign@?$char_traits@G@std@@SAXAAGABG@Z ENDP		; std::char_traits<unsigned short>::assign
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@G@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@G@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@G@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@G@std@@QAEXPAGI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@G@std@@QAEXPAGI@Z PROC NEAR	; std::allocator<unsigned short>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 133  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@G@std@@QAEXPAGI@Z ENDP		; std::allocator<unsigned short>::deallocate
_TEXT	ENDS
PUBLIC	?npos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@2IB ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::npos
PUBLIC	?erase@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@II@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::erase
PUBLIC	?size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::size
PUBLIC	?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEPBGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
;	COMDAT ?npos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@2IB
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
CONST	SEGMENT
?npos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@2IB DD 0ffffffffH ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::npos
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Right.size() < _Roff)

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::size
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00017	73 08		 jae	 SHORT $L51247

; 592  : 			_String_base::_Xran();	// _Roff off end

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L51247:

; 593  : 		size_type _Num = _Right.size() - _Roff;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	e8 00 00 00 00	 call	 ?size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::size
  00029	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  0002c	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 594  : 		if (_Count < _Num)

  0002f	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00032	3b 45 f8	 cmp	 eax, DWORD PTR __Num$[ebp]
  00035	73 06		 jae	 SHORT $L51249

; 595  : 			_Num = _Count;	// trim _Num to size

  00037	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax
$L51249:

; 596  : 
; 597  : 		if (this == &_Right)

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00043	75 25		 jne	 SHORT $L51250

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?npos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@2IB ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::npos
  0004a	50		 push	 eax
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0004e	03 4d f8	 add	 ecx, DWORD PTR __Num$[ebp]
  00051	51		 push	 ecx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?erase@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@II@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::erase
  0005a	8b 55 0c	 mov	 edx, DWORD PTR __Roff$[ebp]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?erase@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@II@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::erase

; 599  : 		else if (_Grow(_Num))

  00068	eb 45		 jmp	 SHORT $L51289
$L51250:
  0006a	6a 00		 push	 0
  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NI_N@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Grow
  00078	0f b6 c8	 movzx	 ecx, al
  0007b	85 c9		 test	 ecx, ecx
  0007d	74 30		 je	 SHORT $L51289

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0007f	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  00082	50		 push	 eax
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEPBGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  0008b	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0008e	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00091	52		 push	 edx
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z ; std::char_traits<unsigned short>::copy
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 602  : 			_Eos(_Num);

  000a3	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos
$L51289:

; 603  : 			}
; 604  : 		return (*this);

  000af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 605  : 		}

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::assign
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::max_size
PUBLIC	?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Copy
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Odt /ZI
;	COMDAT ?_Grow@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -72						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::max_size
  00014	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00017	73 08		 jae	 SHORT $L51293

; 1482 : 			_String_base::_Xlen();	// result too long

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L51293:

; 1483 : 		if (_Myres < _Newsize)

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00027	3b 4d 08	 cmp	 ecx, DWORD PTR __Newsize$[ebp]
  0002a	73 15		 jae	 SHORT $L51294

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00036	52		 push	 edx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  0003f	eb 4a		 jmp	 SHORT $L51295
$L51294:
  00041	0f b6 45 0c	 movzx	 eax, BYTE PTR __Trim$[ebp]
  00045	85 c0		 test	 eax, eax
  00047	74 32		 je	 SHORT $L51296
  00049	83 7d 08 08	 cmp	 DWORD PTR __Newsize$[ebp], 8
  0004d	73 2c		 jae	 SHORT $L51296

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00055	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00058	73 08		 jae	 SHORT $L51537
  0005a	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0005d	89 55 b8	 mov	 DWORD PTR tv81[ebp], edx
  00060	eb 09		 jmp	 SHORT $L51538
$L51537:
  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00068	89 4d b8	 mov	 DWORD PTR tv81[ebp], ecx
$L51538:
  0006b	8b 55 b8	 mov	 edx, DWORD PTR tv81[ebp]
  0006e	52		 push	 edx
  0006f	6a 01		 push	 1
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

  00079	eb 10		 jmp	 SHORT $L51295
$L51296:
  0007b	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0007f	75 0a		 jne	 SHORT $L51295

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

  00081	6a 00		 push	 0
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos
$L51295:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  0008b	33 c0		 xor	 eax, eax
  0008d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00090	1b c0		 sbb	 eax, eax
  00092	f7 d8		 neg	 eax

; 1491 : 		}

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
?_Grow@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Grow
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NPBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NPBG@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  00014	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00017	72 16		 jb	 SHORT $L51302
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00027	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  0002a	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0002d	77 04		 ja	 SHORT $L51301
$L51302:

; 1496 : 			return (false);	// don't ask

  0002f	32 c0		 xor	 al, al
  00031	eb 02		 jmp	 SHORT $L51300
$L51301:

; 1497 : 		else
; 1498 : 			return (true);

  00033	b0 01		 mov	 al, 1
$L51300:

; 1499 : 		}

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?_Inside@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAE_NPBG@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Inside
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 18 08	 cmp	 DWORD PTR [eax+24], 8
  00013	72 0b		 jb	 SHORT $L51543
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv70[ebp], edx
  0001e	eb 09		 jmp	 SHORT $L51544
$L51543:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 b8	 mov	 DWORD PTR tv70[ebp], eax
$L51544:
  00029	8b 45 b8	 mov	 eax, DWORD PTR tv70[ebp]

; 1533 : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
_TEXT	ENDS
PUBLIC	?move@?$char_traits@G@std@@SAPAGPAGPBGI@Z	; std::char_traits<unsigned short>::move
; Function compile flags: /Odt /ZI
;	COMDAT ?erase@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$51311 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00012	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00015	73 08		 jae	 SHORT $L51308

; 794  : 			_String_base::_Xran();	// _Off off end

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L51308:

; 795  : 		if (_Mysize - _Off < _Count)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00025	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00028	3b 4d 0c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0002b	73 0c		 jae	 SHORT $L51309

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00033	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00036	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
$L51309:

; 797  : 		if (0 < _Count)

  00039	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003d	76 51		 jbe	 SHORT $L51310

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00045	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00048	2b 4d 0c	 sub	 ecx, DWORD PTR __Count$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  00054	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00057	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005d	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00060	52		 push	 edx
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  00069	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0006c	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 ?move@?$char_traits@G@std@@SAPAGPAGPBGI@Z ; std::char_traits<unsigned short>::move
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0007e	2b 4d 0c	 sub	 ecx, DWORD PTR __Count$[ebp]
  00081	89 4d f8	 mov	 DWORD PTR __Newsize$51311[ebp], ecx

; 802  : 			_Eos(_Newsize);

  00084	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$51311[ebp]
  00087	50		 push	 eax
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos
$L51310:

; 803  : 			}
; 804  : 		return (*this);

  00090	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 805  : 		}

  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
?erase@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::erase
_TEXT	ENDS
PUBLIC	_wmemmove
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?move@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@G@std@@SAPAGPAGPBGI@Z PROC NEAR	; std::char_traits<unsigned short>::move, COMDAT

; 282  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 283  : 		return (::wmemmove(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _wmemmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 284  : 		}

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?move@?$char_traits@G@std@@SAPAGPAGPBGI@Z ENDP		; std::char_traits<unsigned short>::move
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC NEAR					; COMDAT

; 796  :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 797  :             return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00009	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  0000c	d1 e0		 shl	 eax, 1
  0000e	50		 push	 eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _memmove
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 798  :         }

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
_wmemmove ENDP
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 1110 : 		}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@G@std@@QBEIXZ		; std::allocator<unsigned short>::max_size
; Function compile flags: /Odt /ZI
;	COMDAT ?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -76						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$allocator@G@std@@QBEIXZ ; std::allocator<unsigned short>::max_size
  00014	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00017	83 7d f8 01	 cmp	 DWORD PTR __Num$[ebp], 1
  0001b	77 09		 ja	 SHORT $L51555
  0001d	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00024	eb 09		 jmp	 SHORT $L51556
$L51555:
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  00029	83 e8 01	 sub	 eax, 1
  0002c	89 45 b4	 mov	 DWORD PTR tv68[ebp], eax
$L51556:
  0002f	8b 45 b4	 mov	 eax, DWORD PTR tv68[ebp]

; 1116 : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@G@std@@QAEPAGI@Z		; std::allocator<unsigned short>::allocate
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$1
__catchsym$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z DD 019930520H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
; Function compile flags: /Odt /ZI
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -96						; size = 4
tv144 = -96						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 50	 sub	 esp, 80			; 00000050H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  00025	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00028	83 c8 07	 or	 eax, 7
  0002b	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

  0002e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::max_size
  00036	3b 45 e8	 cmp	 eax, DWORD PTR __Newres$[ebp]
  00039	73 08		 jae	 SHORT $L51320

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

  0003b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

  00041	eb 43		 jmp	 SHORT $L51321
$L51320:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

  00043	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00049	d1 e9		 shr	 ecx, 1
  0004b	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  0004e	33 d2		 xor	 edx, edx
  00050	be 03 00 00 00	 mov	 esi, 3
  00055	f7 f6		 div	 esi
  00057	3b c1		 cmp	 eax, ecx
  00059	73 2b		 jae	 SHORT $L51321
  0005b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  00061	d1 ee		 shr	 esi, 1
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::max_size
  0006b	2b c6		 sub	 eax, esi
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  00073	77 11		 ja	 SHORT $L51321

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0007b	d1 e9		 shr	 ecx, 1
  0007d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00080	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00083	89 4d e8	 mov	 DWORD PTR __Newres$[ebp], ecx
$L51321:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

  00086	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  0008d	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  00090	83 c0 01	 add	 eax, 1
  00093	50		 push	 eax
  00094	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?allocate@?$allocator@G@std@@QAEPAGI@Z ; std::allocator<unsigned short>::allocate
  0009c	89 45 a0	 mov	 DWORD PTR tv144[ebp], eax
  0009f	8b 4d a0	 mov	 ecx, DWORD PTR tv144[ebp]
  000a2	89 4d e4	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000a5	eb 4b		 jmp	 SHORT $L51560
__catch$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$0:

; 1455 : 		_CATCH_ALL

  000a7	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000aa	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ad	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN

  000b0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  000b4	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  000b7	83 c0 01	 add	 eax, 1
  000ba	50		 push	 eax
  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?allocate@?$allocator@G@std@@QAEPAGI@Z ; std::allocator<unsigned short>::allocate
  000c3	89 45 a0	 mov	 DWORD PTR tv145[ebp], eax
  000c6	8b 4d a0	 mov	 ecx, DWORD PTR tv145[ebp]
  000c9	89 4d e4	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000cc	eb 15		 jmp	 SHORT $L51562
__catch$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$1:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

  000ce	6a 00		 push	 0
  000d0	6a 01		 push	 1
  000d2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Tidy

; 1461 : 			_RERAISE;

  000da	6a 00		 push	 0
  000dc	6a 00		 push	 0
  000de	e8 00 00 00 00	 call	 __CxxThrowException@8
$L51562:

; 1462 : 			_CATCH_END

  000e3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

  000ea	b8 00 00 00 00	 mov	 eax, $L51565
  000ef	c3		 ret	 0
$L51565:
  000f0	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$3
$L51560:
  000f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z$3:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

  000f9	83 7d 0c 00	 cmp	 DWORD PTR __Oldlen$[ebp], 0
  000fd	76 19		 jbe	 SHORT $L51326

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000ff	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00102	50		 push	 eax
  00103	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEPAGXZ ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
  0010b	50		 push	 eax
  0010c	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z ; std::char_traits<unsigned short>::copy
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
$L51326:

; 1467 : 		_Tidy(true);

  00118	6a 00		 push	 0
  0011a	6a 01		 push	 1
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEX_NI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

  00124	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00127	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0012a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

  0012d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 4d e8	 mov	 ecx, DWORD PTR __Newres$[ebp]
  00133	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1470 : 		_Eos(_Oldlen);

  00136	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00139	50		 push	 eax
  0013a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXI@Z ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Eos
$L51558:

; 1471 : 		}

  00142	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00145	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXII@Z ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Copy
; Function compile flags: /Odt /ZI
;	COMDAT ?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEPBGXZ
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEPBGXZ PROC NEAR ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr, COMDAT
; _this$ = ecx

; 1536 : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 18 08	 cmp	 DWORD PTR [eax+24], 8
  00013	72 0b		 jb	 SHORT $L51577
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv70[ebp], edx
  0001e	eb 09		 jmp	 SHORT $L51578
$L51577:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 b8	 mov	 DWORD PTR tv70[ebp], eax
$L51578:
  00029	8b 45 b8	 mov	 eax, DWORD PTR tv70[ebp]

; 1538 : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Myptr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEPBGXZ ENDP ; std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Myptr
_TEXT	ENDS
PUBLIC	??$_Allocate@G@std@@YAPAGIPAG@Z			; std::_Allocate<unsigned short>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@G@std@@QAEPAGI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@G@std@@QAEPAGI@Z PROC NEAR	; std::allocator<unsigned short>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@G@std@@YAPAGIPAG@Z ; std::_Allocate<unsigned short>
  00017	83 c4 08	 add	 esp, 8

; 138  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@G@std@@QAEPAGI@Z ENDP		; std::allocator<unsigned short>::allocate
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@G@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@G@std@@QBEIXZ PROC NEAR		; std::allocator<unsigned short>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $L51583
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $L51584
$L51583:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L51584:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@G@std@@QBEIXZ ENDP		; std::allocator<unsigned short>::max_size
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@G@std@@YAPAGIPAG@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@G@std@@YAPAGIPAG@Z PROC NEAR		; std::_Allocate<unsigned short>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	d1 e0		 shl	 eax, 1
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00014	83 c4 04	 add	 esp, 4

; 35   : 	}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Allocate@G@std@@YAPAGIPAG@Z ENDP			; std::_Allocate<unsigned short>
_TEXT	ENDS
END
