; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\inject.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNEJOHCL@GetModuleHandleA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DGIDOA@GetProcAddress?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FACAOGOA@FreeLibrary?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HECAEFLP@TerminateThread?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@POGOAJG@GetCurrentThread?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?InjectLoader@@YGKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InjectLoaderEnd@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InjectAndCall
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DllMain@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_injectdllpath
_BSS	SEGMENT
_injectdllpath DB 0104H DUP (?)
_BSS	ENDS
PUBLIC	_InjectAndCall
PUBLIC	??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@		; `string'
PUBLIC	??_C@_0BB@HNEJOHCL@GetModuleHandleA?$AA@	; `string'
PUBLIC	??_C@_0P@DGIDOA@GetProcAddress?$AA@		; `string'
PUBLIC	??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@		; `string'
PUBLIC	??_C@_0M@FACAOGOA@FreeLibrary?$AA@		; `string'
PUBLIC	??_C@_0BA@HECAEFLP@TerminateThread?$AA@		; `string'
PUBLIC	??_C@_0BB@POGOAJG@GetCurrentThread?$AA@		; `string'
EXTRN	__imp__GetProcAddress@8:NEAR
EXTRN	__imp__VirtualAllocEx@20:NEAR
EXTRN	__imp__VirtualFreeEx@16:NEAR
EXTRN	__imp__CreateRemoteThread@28:NEAR
EXTRN	__imp__LoadLibraryA@4:NEAR
EXTRN	__imp__TerminateThread@8:NEAR
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	__imp__ReadProcessMemory@20:NEAR
EXTRN	__imp__WriteProcessMemory@20:NEAR
EXTRN	__imp__WaitForSingleObject@8:NEAR
EXTRN	_strcpy:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
;	COMDAT ??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
; File c:\documents and settings\marcstgr\my documents\visual studio projects\beta\src\pethooks\inject.cpp
CONST	SEGMENT
??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@ DB 'kernel32.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNEJOHCL@GetModuleHandleA?$AA@
CONST	SEGMENT
??_C@_0BB@HNEJOHCL@GetModuleHandleA?$AA@ DB 'GetModuleHandleA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGIDOA@GetProcAddress?$AA@
CONST	SEGMENT
??_C@_0P@DGIDOA@GetProcAddress?$AA@ DB 'GetProcAddress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@
CONST	SEGMENT
??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@ DB 'LoadLibraryA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FACAOGOA@FreeLibrary?$AA@
CONST	SEGMENT
??_C@_0M@FACAOGOA@FreeLibrary?$AA@ DB 'FreeLibrary', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HECAEFLP@TerminateThread?$AA@
CONST	SEGMENT
??_C@_0BA@HECAEFLP@TerminateThread?$AA@ DB 'TerminateThread', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@POGOAJG@GetCurrentThread?$AA@
CONST	SEGMENT
??_C@_0BB@POGOAJG@GetCurrentThread?$AA@ DB 'GetCurrentThread', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT _InjectAndCall
_TEXT	SEGMENT
tv211 = -652						; size = 4
_remotebuffer$ = -584					; size = 4
_codesize$ = -580					; size = 4
_kernel$ = -576						; size = 4
_data$ = -572						; size = 556
_thread$ = -16						; size = 4
_remotedata$ = -12					; size = 4
_remotecode$ = -8					; size = 4
_error$ = -4						; size = 4
_process$ = 8						; size = 4
_funcname$ = 12						; size = 4
_timeout$ = 16						; size = 4
_buffer$ = 20						; size = 4
_bufsize$ = 24						; size = 4
_outsize$ = 28						; size = 4
_InjectAndCall PROC NEAR				; COMDAT

; 74   : 					BYTE* buffer, size_t bufsize, size_t* outsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 8c 02 00
	00		 sub	 esp, 652		; 0000028cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 75   : 	DWORD error = ERROR_SUCCESS;

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _error$[ebp], 0

; 76   : #define FAIL { error = GetLastError(); goto cleanup; }
; 77   : 
; 78   : 	void* remotecode = NULL;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _remotecode$[ebp], 0

; 79   : 	void* remotedata = NULL;

  0001a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _remotedata$[ebp], 0

; 80   : 	HANDLE thread = NULL;

  00021	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _thread$[ebp], 0

; 81   : 	if (buffer == NULL) bufsize = 0;

  00028	83 7d 14 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  0002c	75 07		 jne	 SHORT $L26477
  0002e	c7 45 18 00 00
	00 00		 mov	 DWORD PTR _bufsize$[ebp], 0
$L26477:

; 82   : 	if (bufsize == 0) buffer = NULL;

  00035	83 7d 18 00	 cmp	 DWORD PTR _bufsize$[ebp], 0
  00039	75 07		 jne	 SHORT $L26478
  0003b	c7 45 14 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp], 0
$L26478:

; 83   : 	if (outsize) *outsize = 0;

  00042	83 7d 1c 00	 cmp	 DWORD PTR _outsize$[ebp], 0
  00046	74 09		 je	 SHORT $L26479
  00048	8b 45 1c	 mov	 eax, DWORD PTR _outsize$[ebp]
  0004b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$L26479:

; 84   : 
; 85   : 	// Prepare all the data that the InjectLoader will need.
; 86   : 	INJECTDATA data;
; 87   : 	HMODULE kernel = LoadLibraryA("kernel32.dll");

  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@MDJJJHMB@kernel32?4dll?$AA@
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  0005c	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _kernel$[ebp], eax

; 88   : 	data.GetModuleHandleA = (GetModuleHandleA_t) GetProcAddress(kernel, "GetModuleHandleA");

  00062	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@HNEJOHCL@GetModuleHandleA?$AA@
  00067	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _kernel$[ebp]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  00074	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _data$[ebp], eax

; 89   : 	data.GetProcAddress = (GetProcAddress_t) GetProcAddress(kernel, "GetProcAddress");

  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@DGIDOA@GetProcAddress?$AA@
  0007f	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _kernel$[ebp]
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0008c	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _data$[ebp+4], eax

; 90   : 	data.LoadLibraryA = (LoadLibraryA_t) GetProcAddress(kernel, "LoadLibraryA");

  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0N@LOMLCOFC@LoadLibraryA?$AA@
  00097	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _kernel$[ebp]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000a4	89 85 cc fd ff
	ff		 mov	 DWORD PTR _data$[ebp+8], eax

; 91   : 	data.FreeLibrary = (FreeLibrary_t) GetProcAddress(kernel, "FreeLibrary");

  000aa	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@FACAOGOA@FreeLibrary?$AA@
  000af	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _kernel$[ebp]
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000bc	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _data$[ebp+12], eax

; 92   : 	data.TerminateThread = (TerminateThread_t) GetProcAddress(kernel, "TerminateThread");

  000c2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@HECAEFLP@TerminateThread?$AA@
  000c7	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _kernel$[ebp]
  000cd	50		 push	 eax
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000d4	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _data$[ebp+16], eax

; 93   : 	data.GetCurrentThread = (GetCurrentThread_t) GetProcAddress(kernel, "GetCurrentThread");

  000da	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@POGOAJG@GetCurrentThread?$AA@
  000df	8b 85 c0 fd ff
	ff		 mov	 eax, DWORD PTR _kernel$[ebp]
  000e5	50		 push	 eax
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  000ec	89 85 d8 fd ff
	ff		 mov	 DWORD PTR _data$[ebp+20], eax

; 94   : 	strcpy(data.injectdllpath, injectdllpath);

  000f2	68 00 00 00 00	 push	 OFFSET FLAT:_injectdllpath
  000f7	8d 85 dc fd ff
	ff		 lea	 eax, DWORD PTR _data$[ebp+24]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 _strcpy
  00103	83 c4 08	 add	 esp, 8

; 95   : 	strcpy(data.injectfuncname, funcname);

  00106	8b 45 0c	 mov	 eax, DWORD PTR _funcname$[ebp]
  00109	50		 push	 eax
  0010a	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _data$[ebp+284]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 _strcpy
  00116	83 c4 08	 add	 esp, 8

; 96   : 	data.bufsize = bufsize;

  00119	8b 45 18	 mov	 eax, DWORD PTR _bufsize$[ebp]
  0011c	89 45 e4	 mov	 DWORD PTR _data$[ebp+544], eax

; 97   : 	data.outsize = 0;

  0011f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _data$[ebp+548], 0

; 98   : 	data.error = 0;

  00126	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _data$[ebp+552], 0

; 99   : 
; 100  : 	// Transfer the loader code, data, and input buffer if any.
; 101  : 	size_t codesize = (char*) InjectLoaderEnd - (char*) InjectLoader;

  0012d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?InjectLoaderEnd@@YAXXZ ; InjectLoaderEnd
  00132	2d 00 00 00 00	 sub	 eax, OFFSET FLAT:?InjectLoader@@YGKPAX@Z ; InjectLoader
  00137	89 85 bc fd ff
	ff		 mov	 DWORD PTR _codesize$[ebp], eax

; 102  : 	remotecode = VirtualAllocEx(process, NULL, codesize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

  0013d	6a 40		 push	 64			; 00000040H
  0013f	68 00 10 00 00	 push	 4096			; 00001000H
  00144	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _codesize$[ebp]
  0014a	50		 push	 eax
  0014b	6a 00		 push	 0
  0014d	8b 4d 08	 mov	 ecx, DWORD PTR _process$[ebp]
  00150	51		 push	 ecx
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAllocEx@20
  00157	89 45 f8	 mov	 DWORD PTR _remotecode$[ebp], eax

; 103  : 	remotedata = VirtualAllocEx(process, NULL, sizeof(data) + bufsize, MEM_COMMIT, PAGE_READWRITE);

  0015a	6a 04		 push	 4
  0015c	68 00 10 00 00	 push	 4096			; 00001000H
  00161	8b 45 18	 mov	 eax, DWORD PTR _bufsize$[ebp]
  00164	05 2c 02 00 00	 add	 eax, 556		; 0000022cH
  00169	50		 push	 eax
  0016a	6a 00		 push	 0
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR _process$[ebp]
  0016f	51		 push	 ecx
  00170	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualAllocEx@20
  00176	89 45 f4	 mov	 DWORD PTR _remotedata$[ebp], eax

; 104  : 	void* remotebuffer = (INJECTDATA*) remotedata + 1;

  00179	8b 45 f4	 mov	 eax, DWORD PTR _remotedata$[ebp]
  0017c	05 2c 02 00 00	 add	 eax, 556		; 0000022cH
  00181	89 85 b8 fd ff
	ff		 mov	 DWORD PTR _remotebuffer$[ebp], eax

; 105  : 	if (!remotecode || !remotedata) FAIL;

  00187	83 7d f8 00	 cmp	 DWORD PTR _remotecode$[ebp], 0
  0018b	74 06		 je	 SHORT $L26501
  0018d	83 7d f4 00	 cmp	 DWORD PTR _remotedata$[ebp], 0
  00191	75 0e		 jne	 SHORT $L26500
$L26501:
  00193	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00199	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  0019c	e9 7f 01 00 00	 jmp	 $cleanup$26502
$L26500:

; 106  : 	if (!WriteProcessMemory(process, remotecode, InjectLoader, codesize, NULL)) FAIL;

  001a1	6a 00		 push	 0
  001a3	8b 85 bc fd ff
	ff		 mov	 eax, DWORD PTR _codesize$[ebp]
  001a9	50		 push	 eax
  001aa	68 00 00 00 00	 push	 OFFSET FLAT:?InjectLoader@@YGKPAX@Z ; InjectLoader
  001af	8b 4d f8	 mov	 ecx, DWORD PTR _remotecode$[ebp]
  001b2	51		 push	 ecx
  001b3	8b 55 08	 mov	 edx, DWORD PTR _process$[ebp]
  001b6	52		 push	 edx
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
  001bd	85 c0		 test	 eax, eax
  001bf	75 0e		 jne	 SHORT $L26504
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001c7	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  001ca	e9 51 01 00 00	 jmp	 $cleanup$26502
$L26504:

; 107  : 	if (!WriteProcessMemory(process, remotedata, &data, sizeof(data), NULL)) FAIL;

  001cf	6a 00		 push	 0
  001d1	68 2c 02 00 00	 push	 556			; 0000022cH
  001d6	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _data$[ebp]
  001dc	50		 push	 eax
  001dd	8b 4d f4	 mov	 ecx, DWORD PTR _remotedata$[ebp]
  001e0	51		 push	 ecx
  001e1	8b 55 08	 mov	 edx, DWORD PTR _process$[ebp]
  001e4	52		 push	 edx
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
  001eb	85 c0		 test	 eax, eax
  001ed	75 0e		 jne	 SHORT $L26506
  001ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001f5	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  001f8	e9 23 01 00 00	 jmp	 $cleanup$26502
$L26506:

; 108  : 	if (buffer && !WriteProcessMemory(process, remotebuffer, buffer, bufsize, NULL)) FAIL;

  001fd	83 7d 14 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00201	74 2d		 je	 SHORT $L26508
  00203	6a 00		 push	 0
  00205	8b 45 18	 mov	 eax, DWORD PTR _bufsize$[ebp]
  00208	50		 push	 eax
  00209	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0020c	51		 push	 ecx
  0020d	8b 95 b8 fd ff
	ff		 mov	 edx, DWORD PTR _remotebuffer$[ebp]
  00213	52		 push	 edx
  00214	8b 45 08	 mov	 eax, DWORD PTR _process$[ebp]
  00217	50		 push	 eax
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteProcessMemory@20
  0021e	85 c0		 test	 eax, eax
  00220	75 0e		 jne	 SHORT $L26508
  00222	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00228	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  0022b	e9 f0 00 00 00	 jmp	 $cleanup$26502
$L26508:

; 109  : 
; 110  : 	// Launch the loader in the remote process.
; 111  : 	thread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE) remotecode, remotedata, 0, NULL);

  00230	6a 00		 push	 0
  00232	6a 00		 push	 0
  00234	8b 45 f4	 mov	 eax, DWORD PTR _remotedata$[ebp]
  00237	50		 push	 eax
  00238	8b 4d f8	 mov	 ecx, DWORD PTR _remotecode$[ebp]
  0023b	51		 push	 ecx
  0023c	6a 00		 push	 0
  0023e	6a 00		 push	 0
  00240	8b 55 08	 mov	 edx, DWORD PTR _process$[ebp]
  00243	52		 push	 edx
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateRemoteThread@28
  0024a	89 45 f0	 mov	 DWORD PTR _thread$[ebp], eax

; 112  : 	if (!thread) FAIL;

  0024d	83 7d f0 00	 cmp	 DWORD PTR _thread$[ebp], 0
  00251	75 0e		 jne	 SHORT $L26511
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00259	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  0025c	e9 bf 00 00 00	 jmp	 $cleanup$26502
$L26511:

; 113  : 	switch (WaitForSingleObject(thread, timeout)) {

  00261	8b 45 10	 mov	 eax, DWORD PTR _timeout$[ebp]
  00264	50		 push	 eax
  00265	8b 4d f0	 mov	 ecx, DWORD PTR _thread$[ebp]
  00268	51		 push	 ecx
  00269	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
  0026f	89 85 74 fd ff
	ff		 mov	 DWORD PTR tv211[ebp], eax
  00275	81 bd 74 fd ff
	ff 02 01 00 00	 cmp	 DWORD PTR tv211[ebp], 258 ; 00000102H
  0027f	74 19		 je	 SHORT $L26520
  00281	83 bd 74 fd ff
	ff ff		 cmp	 DWORD PTR tv211[ebp], -1
  00288	74 02		 je	 SHORT $L26518
  0028a	eb 25		 jmp	 SHORT $L26514
$L26518:

; 114  : 		case WAIT_FAILED:
; 115  : 			FAIL;

  0028c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00292	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  00295	e9 86 00 00 00	 jmp	 $cleanup$26502
$L26520:

; 116  : 		case WAIT_TIMEOUT:
; 117  : 			TerminateThread(thread, FALSE);

  0029a	6a 00		 push	 0
  0029c	8b 45 f0	 mov	 eax, DWORD PTR _thread$[ebp]
  0029f	50		 push	 eax
  002a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateThread@8

; 118  : 			FAIL;

  002a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002ac	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  002af	eb 6f		 jmp	 SHORT $cleanup$26502
$L26514:

; 119  : 	}
; 120  : 
; 121  : 	// Retrieve the result.
; 122  : 	if (!ReadProcessMemory(process, remotedata, &data, sizeof(data), NULL)) FAIL;

  002b1	6a 00		 push	 0
  002b3	68 2c 02 00 00	 push	 556			; 0000022cH
  002b8	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR _data$[ebp]
  002be	50		 push	 eax
  002bf	8b 4d f4	 mov	 ecx, DWORD PTR _remotedata$[ebp]
  002c2	51		 push	 ecx
  002c3	8b 55 08	 mov	 edx, DWORD PTR _process$[ebp]
  002c6	52		 push	 edx
  002c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
  002cd	85 c0		 test	 eax, eax
  002cf	75 0b		 jne	 SHORT $L26522
  002d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002d7	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  002da	eb 44		 jmp	 SHORT $cleanup$26502
$L26522:

; 123  : 	if (buffer && !ReadProcessMemory(process, remotebuffer, buffer, bufsize, NULL)) FAIL;

  002dc	83 7d 14 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  002e0	74 2a		 je	 SHORT $L26524
  002e2	6a 00		 push	 0
  002e4	8b 45 18	 mov	 eax, DWORD PTR _bufsize$[ebp]
  002e7	50		 push	 eax
  002e8	8b 4d 14	 mov	 ecx, DWORD PTR _buffer$[ebp]
  002eb	51		 push	 ecx
  002ec	8b 95 b8 fd ff
	ff		 mov	 edx, DWORD PTR _remotebuffer$[ebp]
  002f2	52		 push	 edx
  002f3	8b 45 08	 mov	 eax, DWORD PTR _process$[ebp]
  002f6	50		 push	 eax
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadProcessMemory@20
  002fd	85 c0		 test	 eax, eax
  002ff	75 0b		 jne	 SHORT $L26524
  00301	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00307	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
  0030a	eb 14		 jmp	 SHORT $cleanup$26502
$L26524:

; 124  : 	if (outsize) *outsize = data.outsize;

  0030c	83 7d 1c 00	 cmp	 DWORD PTR _outsize$[ebp], 0
  00310	74 08		 je	 SHORT $L26526
  00312	8b 45 1c	 mov	 eax, DWORD PTR _outsize$[ebp]
  00315	8b 4d e8	 mov	 ecx, DWORD PTR _data$[ebp+548]
  00318	89 08		 mov	 DWORD PTR [eax], ecx
$L26526:

; 125  : 	error = data.error;

  0031a	8b 45 ec	 mov	 eax, DWORD PTR _data$[ebp+552]
  0031d	89 45 fc	 mov	 DWORD PTR _error$[ebp], eax
$cleanup$26502:

; 126  : 
; 127  : cleanup:
; 128  : 	if (thread) CloseHandle(thread);

  00320	83 7d f0 00	 cmp	 DWORD PTR _thread$[ebp], 0
  00324	74 0a		 je	 SHORT $L26527
  00326	8b 45 f0	 mov	 eax, DWORD PTR _thread$[ebp]
  00329	50		 push	 eax
  0032a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
$L26527:

; 129  : 	if (remotecode) VirtualFreeEx(process, remotecode, 0, MEM_RELEASE);

  00330	83 7d f8 00	 cmp	 DWORD PTR _remotecode$[ebp], 0
  00334	74 15		 je	 SHORT $L26528
  00336	68 00 80 00 00	 push	 32768			; 00008000H
  0033b	6a 00		 push	 0
  0033d	8b 45 f8	 mov	 eax, DWORD PTR _remotecode$[ebp]
  00340	50		 push	 eax
  00341	8b 4d 08	 mov	 ecx, DWORD PTR _process$[ebp]
  00344	51		 push	 ecx
  00345	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFreeEx@16
$L26528:

; 130  : 	if (remotedata) VirtualFreeEx(process, remotedata, 0, MEM_RELEASE);

  0034b	83 7d f4 00	 cmp	 DWORD PTR _remotedata$[ebp], 0
  0034f	74 15		 je	 SHORT $L26529
  00351	68 00 80 00 00	 push	 32768			; 00008000H
  00356	6a 00		 push	 0
  00358	8b 45 f4	 mov	 eax, DWORD PTR _remotedata$[ebp]
  0035b	50		 push	 eax
  0035c	8b 4d 08	 mov	 ecx, DWORD PTR _process$[ebp]
  0035f	51		 push	 ecx
  00360	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualFreeEx@16
$L26529:

; 131  : 	return error;

  00366	8b 45 fc	 mov	 eax, DWORD PTR _error$[ebp]

; 132  : }

  00369	5f		 pop	 edi
  0036a	5e		 pop	 esi
  0036b	5b		 pop	 ebx
  0036c	8b e5		 mov	 esp, ebp
  0036e	5d		 pop	 ebp
  0036f	c3		 ret	 0
_InjectAndCall ENDP
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?InjectLoader@@YGKPAX@Z
_TEXT	SEGMENT
_buffer$ = -16						; size = 4
_function$ = -12					; size = 4
_injectdll$ = -8					; size = 4
_data$ = -4						; size = 4
_ptr$ = 8						; size = 4
?InjectLoader@@YGKPAX@Z PROC NEAR			; InjectLoader, COMDAT

; 32   : static DWORD __stdcall InjectLoader(void* ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 33   : 	INJECTDATA* data = (INJECTDATA*) ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR _ptr$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _data$[ebp], eax

; 34   : 	HMODULE injectdll = data->LoadLibraryA(data->injectdllpath);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00012	83 c0 18	 add	 eax, 24			; 00000018H
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _data$[ebp]
  00019	ff 51 08	 call	 DWORD PTR [ecx+8]
  0001c	89 45 f8	 mov	 DWORD PTR _injectdll$[ebp], eax

; 35   : 	INJECTEDFUNCTION function =
; 36   : 		(INJECTEDFUNCTION) data->GetProcAddress(injectdll, data->injectfuncname);

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00022	05 1c 01 00 00	 add	 eax, 284		; 0000011cH
  00027	50		 push	 eax
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _injectdll$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _data$[ebp]
  0002f	ff 52 04	 call	 DWORD PTR [edx+4]
  00032	89 45 f4	 mov	 DWORD PTR _function$[ebp], eax

; 37   : 
; 38   : 	BYTE* buffer = (BYTE*) (data + 1); // end of the INJECTDATA structure

  00035	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00038	05 2c 02 00 00	 add	 eax, 556		; 0000022cH
  0003d	89 45 f0	 mov	 DWORD PTR _buffer$[ebp], eax

; 39   : 	if (function) data->outsize = function(data->bufsize ? buffer : NULL, data->bufsize);

  00040	83 7d f4 00	 cmp	 DWORD PTR _function$[ebp], 0
  00044	74 2a		 je	 SHORT $L26457
  00046	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00049	8b 88 20 02 00
	00		 mov	 ecx, DWORD PTR [eax+544]
  0004f	51		 push	 ecx
  00050	8b 55 fc	 mov	 edx, DWORD PTR _data$[ebp]
  00053	8b 82 20 02 00
	00		 mov	 eax, DWORD PTR [edx+544]
  00059	f7 d8		 neg	 eax
  0005b	1b c0		 sbb	 eax, eax
  0005d	23 45 f0	 and	 eax, DWORD PTR _buffer$[ebp]
  00060	50		 push	 eax
  00061	ff 55 f4	 call	 DWORD PTR _function$[ebp]
  00064	83 c4 08	 add	 esp, 8
  00067	8b 4d fc	 mov	 ecx, DWORD PTR _data$[ebp]
  0006a	89 81 24 02 00
	00		 mov	 DWORD PTR [ecx+548], eax
$L26457:

; 40   : 	
; 41   : 	if (!injectdll) data->error = ERROR_FILE_NOT_FOUND;

  00070	83 7d f8 00	 cmp	 DWORD PTR _injectdll$[ebp], 0
  00074	75 0f		 jne	 SHORT $L26458
  00076	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  00079	c7 80 28 02 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+552], 2

; 42   : 	else if (!function) data->error = ERROR_INVALID_FUNCTION;

  00083	eb 22		 jmp	 SHORT $L26459
$L26458:
  00085	83 7d f4 00	 cmp	 DWORD PTR _function$[ebp], 0
  00089	75 0f		 jne	 SHORT $L26460
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  0008e	c7 80 28 02 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+552], 1

; 43   : 	else data->error = ERROR_SUCCESS;

  00098	eb 0d		 jmp	 SHORT $L26459
$L26460:
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  0009d	c7 80 28 02 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+552], 0
$L26459:

; 44   : 	if (injectdll) data->FreeLibrary(injectdll);

  000a7	83 7d f8 00	 cmp	 DWORD PTR _injectdll$[ebp], 0
  000ab	74 0a		 je	 SHORT $L26462
  000ad	8b 45 f8	 mov	 eax, DWORD PTR _injectdll$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _data$[ebp]
  000b4	ff 51 0c	 call	 DWORD PTR [ecx+12]
$L26462:

; 45   : 
; 46   : 	// For some reason, if we just return here, occasionally the thread gets
; 47   : 	// stuck and never returns.  Explicitly terminating the thread at this
; 48   : 	// point seems to make injected calls finish much more reliably.
; 49   : 	return data->TerminateThread(data->GetCurrentThread(), 0);

  000b7	6a 00		 push	 0
  000b9	8b 45 fc	 mov	 eax, DWORD PTR _data$[ebp]
  000bc	ff 50 14	 call	 DWORD PTR [eax+20]
  000bf	50		 push	 eax
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _data$[ebp]
  000c3	ff 51 10	 call	 DWORD PTR [ecx+16]

; 50   : }

  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
?InjectLoader@@YGKPAX@Z ENDP				; InjectLoader
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?InjectLoaderEnd@@YAXXZ
_TEXT	SEGMENT
?InjectLoaderEnd@@YAXXZ PROC NEAR			; InjectLoaderEnd, COMDAT

; 54   : static void InjectLoaderEnd() { }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?InjectLoaderEnd@@YAXXZ ENDP				; InjectLoaderEnd
_TEXT	ENDS
PUBLIC	_DllMain@12
EXTRN	__imp__GetModuleFileNameA@12:NEAR
; Function compile flags: /Odt /ZI
;	COMDAT _DllMain@12
_TEXT	SEGMENT
_module$ = 8						; size = 4
_reason$ = 12						; size = 4
_reserved$ = 16						; size = 4
_DllMain@12 PROC NEAR					; COMDAT

; 135  : BOOL WINAPI DllMain(HMODULE module, DWORD reason, void* reserved) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 136  : 	if (reason == DLL_PROCESS_ATTACH) {

  00009	83 7d 0c 01	 cmp	 DWORD PTR _reason$[ebp], 1
  0000d	75 14		 jne	 SHORT $L26535

; 137  : 		GetModuleFileNameA(module, injectdllpath, MAX_PATH - 2);

  0000f	68 02 01 00 00	 push	 258			; 00000102H
  00014	68 00 00 00 00	 push	 OFFSET FLAT:_injectdllpath
  00019	8b 45 08	 mov	 eax, DWORD PTR _module$[ebp]
  0001c	50		 push	 eax
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
$L26535:

; 138  : 	}
; 139  :     return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 140  : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
END
