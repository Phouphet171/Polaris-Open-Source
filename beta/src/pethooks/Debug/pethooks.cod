; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\pethooks.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BB@FJOKJKBI@GetOpenFileNameA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEJLPAEO@GetSaveFileNameA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EFHCCPMP@GetOpenFileNameW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DIADEFJJ@GetSaveFileNameW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MFFIAPJA@GetClipboardData?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GJGAPMJD@CloseClipboard?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HMCBMPHP@SetClipboardViewer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@OMBCEPLE@ChangeClipboardChain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DNLJNOAA@comdlg32?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06KMMDPPA@user32?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ??1Request@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GRequest@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewGetOpenFileNameA@@YGHPAUtagOFNA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewGetSaveFileNameA@@YGHPAUtagOFNA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewGetOpenFileNameW@@YGHPAUtagOFNW@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewGetSaveFileNameW@@YGHPAUtagOFNW@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E3
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E4
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?NewGetClipboardData@@YGPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewCloseClipboard@@YGHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ApplyHooks
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@V312@ABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAXIABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAXV?$allocator@PAX@std@@@std@@IAE@V?$allocator@PAX@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAX@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEAAPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAX@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEABQAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAX@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAXIPAXV?$allocator@PAX@std@@@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAPAXPAX@std@@YAXPAPAX0ABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAXIPAX@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAXIPAX@std@@YAXPAPAXIABQAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7Request@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z		; GetFileNameA
PUBLIC	__real@40f5180000000000
EXTRN	?initiate@RPCClient@@QAEPAVRequest@@PBDI@Z:NEAR	; RPCClient::initiate
EXTRN	__except_list:DWORD
EXTRN	__fltused:NEAR
EXTRN	___CxxFrameHandler:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_strlen:NEAR
EXTRN	??1Message@@QAE@XZ:NEAR				; Message::~Message
EXTRN	?cast@Message@@QAEXPAXI@Z:NEAR			; Message::cast
EXTRN	?fix@Message@@QAEXPAXI@Z:NEAR			; Message::fix
EXTRN	?promise@Serializer@@QAEXPBXI@Z:NEAR		; Serializer::promise
EXTRN	?promise@Serializer@@QAEXPBD@Z:NEAR		; Serializer::promise
EXTRN	?send@Serializer@@QAEXPBXI@Z:NEAR		; Serializer::send
EXTRN	?send@Serializer@@QAEXPBD@Z:NEAR		; Serializer::send
;	COMDAT xdata$x
; File c:\documents and settings\marcstgr\my documents\visual studio projects\beta\src\pethooks\pethooks.cpp
xdata$x	SEGMENT
__unwindtable$?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z$0
__ehfuncinfo$?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __real@40f5180000000000
CONST	SEGMENT
__real@40f5180000000000 DQ 040f5180000000000r	; 86400
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z
_TEXT	SEGMENT
$T28217 = -136						; size = 4
_selected$ = -68					; size = 4
_response$ = -64					; size = 20
_FlagsEx$27134 = -44					; size = 4
_dwReserved$27133 = -40					; size = 4
_pvReserved$27132 = -36					; size = 4
_last$27120 = -32					; size = 4
_first$27119 = -28					; size = 4
_lpstrFilter_length$ = -24				; size = 4
_request$ = -20						; size = 4
_sentStructSize$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_method_name$ = 8					; size = 4
_lpofn$ = 12						; size = 4
?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z PROC NEAR		; GetFileNameA, COMDAT

; 19   : BOOL WINAPI GetFileNameA(const char* method_name, LPOPENFILENAMEA lpofn) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 7c	 sub	 esp, 124		; 0000007cH
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 20   : 
; 21   :     // We only know how to send stuff we understand and should only send stuff the client understands.
; 22   :     DWORD sentStructSize = lpofn->lStructSize;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d f0	 mov	 DWORD PTR _sentStructSize$[ebp], ecx

; 23   :     if (sizeof(OPENFILENAMEA) < sentStructSize) {

  00026	83 7d f0 58	 cmp	 DWORD PTR _sentStructSize$[ebp], 88 ; 00000058H
  0002a	76 07		 jbe	 SHORT $L27113

; 24   :         sentStructSize = sizeof(OPENFILENAMEA);

  0002c	c7 45 f0 58 00
	00 00		 mov	 DWORD PTR _sentStructSize$[ebp], 88 ; 00000058H
$L27113:

; 25   :     }
; 26   :     Request* request = client->initiate(method_name, sizeof(OPENFILENAMEA));

  00033	6a 58		 push	 88			; 00000058H
  00035	8b 45 08	 mov	 eax, DWORD PTR _method_name$[ebp]
  00038	50		 push	 eax
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?client@@3PAVRPCClient@@A ; client
  0003f	e8 00 00 00 00	 call	 ?initiate@RPCClient@@QAEPAVRequest@@PBDI@Z ; RPCClient::initiate
  00044	89 45 ec	 mov	 DWORD PTR _request$[ebp], eax

; 27   :     request->send(&sentStructSize, sizeof sentStructSize);

  00047	6a 04		 push	 4
  00049	8d 45 f0	 lea	 eax, DWORD PTR _sentStructSize$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00050	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 28   :     request->send(&lpofn->hwndOwner, sizeof lpofn->hwndOwner);

  00055	6a 04		 push	 4
  00057	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0005a	83 c0 04	 add	 eax, 4
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00061	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 29   :     request->send(&lpofn->hInstance, sizeof lpofn->hInstance);

  00066	6a 04		 push	 4
  00068	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0006b	83 c0 08	 add	 eax, 8
  0006e	50		 push	 eax
  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00072	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 30   :     size_t lpstrFilter_length;
; 31   :     if (lpofn->lpstrFilter) {

  00077	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0007a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0007e	74 59		 je	 SHORT $L27118

; 32   :         const char* first = lpofn->lpstrFilter;

  00080	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00083	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00086	89 4d e4	 mov	 DWORD PTR _first$27119[ebp], ecx

; 33   :         const char* last = first;

  00089	8b 45 e4	 mov	 eax, DWORD PTR _first$27119[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR _last$27120[ebp], eax
$L27121:

; 34   :         do {
; 35   :             last += strlen(last) + 1;

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _last$27120[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _strlen
  00098	83 c4 04	 add	 esp, 4
  0009b	8b 4d e0	 mov	 ecx, DWORD PTR _last$27120[ebp]
  0009e	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  000a2	89 55 e0	 mov	 DWORD PTR _last$27120[ebp], edx

; 36   :             last += strlen(last) + 1;

  000a5	8b 45 e0	 mov	 eax, DWORD PTR _last$27120[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _strlen
  000ae	83 c4 04	 add	 esp, 4
  000b1	8b 4d e0	 mov	 ecx, DWORD PTR _last$27120[ebp]
  000b4	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  000b8	89 55 e0	 mov	 DWORD PTR _last$27120[ebp], edx

; 37   :         } while(*last != '\0');

  000bb	8b 45 e0	 mov	 eax, DWORD PTR _last$27120[ebp]
  000be	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c1	85 c9		 test	 ecx, ecx
  000c3	75 ca		 jne	 SHORT $L27121

; 38   :         ++last;

  000c5	8b 45 e0	 mov	 eax, DWORD PTR _last$27120[ebp]
  000c8	83 c0 01	 add	 eax, 1
  000cb	89 45 e0	 mov	 DWORD PTR _last$27120[ebp], eax

; 39   :         lpstrFilter_length = last - first;

  000ce	8b 45 e0	 mov	 eax, DWORD PTR _last$27120[ebp]
  000d1	2b 45 e4	 sub	 eax, DWORD PTR _first$27119[ebp]
  000d4	89 45 e8	 mov	 DWORD PTR _lpstrFilter_length$[ebp], eax

; 40   :     } else {

  000d7	eb 07		 jmp	 SHORT $L27124
$L27118:

; 41   :         lpstrFilter_length = 0;

  000d9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _lpstrFilter_length$[ebp], 0
$L27124:

; 42   :     }
; 43   :     request->promise(lpofn->lpstrFilter, lpstrFilter_length * sizeof(char));

  000e0	8b 45 e8	 mov	 eax, DWORD PTR _lpstrFilter_length$[ebp]
  000e3	50		 push	 eax
  000e4	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  000e7	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ea	52		 push	 edx
  000eb	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  000ee	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBXI@Z ; Serializer::promise

; 44   :     request->promise(lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter * sizeof(char));

  000f3	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  000f6	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000f9	51		 push	 ecx
  000fa	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  000fd	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00100	50		 push	 eax
  00101	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00104	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBXI@Z ; Serializer::promise

; 45   :     request->send(&lpofn->nMaxCustFilter, sizeof lpofn->nMaxCustFilter);

  00109	6a 04		 push	 4
  0010b	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0010e	83 c0 14	 add	 eax, 20			; 00000014H
  00111	50		 push	 eax
  00112	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00115	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 46   :     request->send(&lpofn->nFilterIndex, sizeof lpofn->nFilterIndex);

  0011a	6a 04		 push	 4
  0011c	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0011f	83 c0 18	 add	 eax, 24			; 00000018H
  00122	50		 push	 eax
  00123	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00126	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 47   :     request->promise(lpofn->lpstrFile, lpofn->nMaxFile * sizeof(char));

  0012b	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0012e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00131	51		 push	 ecx
  00132	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  00135	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00138	50		 push	 eax
  00139	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0013c	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBXI@Z ; Serializer::promise

; 48   :     request->send(&lpofn->nMaxFile, sizeof lpofn->nMaxFile);

  00141	6a 04		 push	 4
  00143	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00146	83 c0 20	 add	 eax, 32			; 00000020H
  00149	50		 push	 eax
  0014a	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0014d	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 49   :     request->promise(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle * sizeof(char));

  00152	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00155	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00158	51		 push	 ecx
  00159	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  0015c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0015f	50		 push	 eax
  00160	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00163	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBXI@Z ; Serializer::promise

; 50   :     request->send(&lpofn->nMaxFileTitle, sizeof lpofn->nMaxFileTitle);

  00168	6a 04		 push	 4
  0016a	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0016d	83 c0 28	 add	 eax, 40			; 00000028H
  00170	50		 push	 eax
  00171	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00174	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 51   :     request->promise(lpofn->lpstrInitialDir);

  00179	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0017c	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0017f	51		 push	 ecx
  00180	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00183	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBD@Z ; Serializer::promise

; 52   :     request->promise(lpofn->lpstrTitle);

  00188	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0018b	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0018e	51		 push	 ecx
  0018f	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00192	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBD@Z ; Serializer::promise

; 53   :     request->send(&lpofn->Flags, sizeof lpofn->Flags);

  00197	6a 04		 push	 4
  00199	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0019c	83 c0 34	 add	 eax, 52			; 00000034H
  0019f	50		 push	 eax
  001a0	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001a3	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 54   :     request->send(&lpofn->nFileOffset, sizeof lpofn->nFileOffset);

  001a8	6a 02		 push	 2
  001aa	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001ad	83 c0 38	 add	 eax, 56			; 00000038H
  001b0	50		 push	 eax
  001b1	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001b4	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 55   :     request->send(&lpofn->nFileExtension, sizeof lpofn->nFileExtension);

  001b9	6a 02		 push	 2
  001bb	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001be	83 c0 3a	 add	 eax, 58			; 0000003aH
  001c1	50		 push	 eax
  001c2	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001c5	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 56   :     request->promise(lpofn->lpstrDefExt);

  001ca	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001cd	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  001d0	51		 push	 ecx
  001d1	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001d4	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBD@Z ; Serializer::promise

; 57   :     request->send(&lpofn->lCustData, sizeof lpofn->lCustData);

  001d9	6a 04		 push	 4
  001db	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001de	83 c0 40	 add	 eax, 64			; 00000040H
  001e1	50		 push	 eax
  001e2	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001e5	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 58   :     request->send(&lpofn->lpfnHook, sizeof lpofn->lpfnHook);

  001ea	6a 04		 push	 4
  001ec	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001ef	83 c0 44	 add	 eax, 68			; 00000044H
  001f2	50		 push	 eax
  001f3	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001f6	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 59   :     request->send(&lpofn->lpTemplateName, sizeof lpofn->lpTemplateName);

  001fb	6a 04		 push	 4
  001fd	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00200	83 c0 48	 add	 eax, 72			; 00000048H
  00203	50		 push	 eax
  00204	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00207	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 60   :     if (sentStructSize == sizeof(OPENFILENAMEA)) {

  0020c	83 7d f0 58	 cmp	 DWORD PTR _sentStructSize$[ebp], 88 ; 00000058H
  00210	75 35		 jne	 SHORT $L27130

; 61   :         request->send(&lpofn->pvReserved, sizeof lpofn->pvReserved);

  00212	6a 04		 push	 4
  00214	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00217	83 c0 4c	 add	 eax, 76			; 0000004cH
  0021a	50		 push	 eax
  0021b	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0021e	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 62   :         request->send(&lpofn->dwReserved, sizeof lpofn->dwReserved);

  00223	6a 04		 push	 4
  00225	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00228	83 c0 50	 add	 eax, 80			; 00000050H
  0022b	50		 push	 eax
  0022c	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0022f	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 63   :         request->send(&lpofn->FlagsEx, sizeof lpofn->FlagsEx);

  00234	6a 04		 push	 4
  00236	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00239	83 c0 54	 add	 eax, 84			; 00000054H
  0023c	50		 push	 eax
  0023d	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00240	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 64   :     } else {

  00245	eb 3f		 jmp	 SHORT $L27131
$L27130:

; 65   :         void* pvReserved = 0;

  00247	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pvReserved$27132[ebp], 0

; 66   :         DWORD dwReserved = 0;

  0024e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _dwReserved$27133[ebp], 0

; 67   :         DWORD FlagsEx = 0;

  00255	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _FlagsEx$27134[ebp], 0

; 68   :         request->send(&pvReserved, sizeof pvReserved);

  0025c	6a 04		 push	 4
  0025e	8d 45 dc	 lea	 eax, DWORD PTR _pvReserved$27132[ebp]
  00261	50		 push	 eax
  00262	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00265	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 69   :         request->send(&dwReserved, sizeof dwReserved);

  0026a	6a 04		 push	 4
  0026c	8d 45 d8	 lea	 eax, DWORD PTR _dwReserved$27133[ebp]
  0026f	50		 push	 eax
  00270	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00273	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 70   :         request->send(&FlagsEx, sizeof FlagsEx);

  00278	6a 04		 push	 4
  0027a	8d 45 d4	 lea	 eax, DWORD PTR _FlagsEx$27134[ebp]
  0027d	50		 push	 eax
  0027e	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00281	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send
$L27131:

; 71   :     }
; 72   : 
; 73   :     request->send(lpofn->lpstrFilter, lpstrFilter_length * sizeof(char));

  00286	8b 45 e8	 mov	 eax, DWORD PTR _lpstrFilter_length$[ebp]
  00289	50		 push	 eax
  0028a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  0028d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00290	52		 push	 edx
  00291	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00294	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 74   :     request->send(lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter * sizeof(char));

  00299	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0029c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0029f	51		 push	 ecx
  002a0	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  002a3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002a6	50		 push	 eax
  002a7	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002aa	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 75   :     request->send(lpofn->lpstrFile, lpofn->nMaxFile * sizeof(char));

  002af	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002b2	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  002b5	51		 push	 ecx
  002b6	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  002b9	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  002bc	50		 push	 eax
  002bd	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002c0	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 76   :     request->send(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle * sizeof(char));

  002c5	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002c8	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  002cb	51		 push	 ecx
  002cc	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  002cf	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  002d2	50		 push	 eax
  002d3	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002d6	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 77   :     request->send(lpofn->lpstrInitialDir);

  002db	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002de	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  002e1	51		 push	 ecx
  002e2	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002e5	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBD@Z ; Serializer::send

; 78   :     request->send(lpofn->lpstrTitle);

  002ea	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002ed	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  002f0	51		 push	 ecx
  002f1	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002f4	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBD@Z ; Serializer::send

; 79   :     request->send(lpofn->lpstrDefExt);

  002f9	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002fc	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  002ff	51		 push	 ecx
  00300	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00303	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBD@Z ; Serializer::send

; 80   : 
; 81   :     Message response = request->finish(true, 60 * 60 * 24);

  00308	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@40f5180000000000
  0030e	83 ec 08	 sub	 esp, 8
  00311	dd 1c 24	 fstp	 QWORD PTR [esp]
  00314	6a 01		 push	 1
  00316	8d 45 c0	 lea	 eax, DWORD PTR _response$[ebp]
  00319	50		 push	 eax
  0031a	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0031d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0031f	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00322	ff 52 04	 call	 DWORD PTR [edx+4]
  00325	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 82   :     LPOPENFILENAMEA selected;
; 83   :     response.cast(&selected, sizeof(OPENFILENAMEA));

  0032c	6a 58		 push	 88			; 00000058H
  0032e	8d 45 bc	 lea	 eax, DWORD PTR _selected$[ebp]
  00331	50		 push	 eax
  00332	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  00335	e8 00 00 00 00	 call	 ?cast@Message@@QAEXPAXI@Z ; Message::cast

; 84   :     if (selected) {

  0033a	83 7d bc 00	 cmp	 DWORD PTR _selected$[ebp], 0
  0033e	0f 84 03 01 00
	00		 je	 $L27143

; 85   :         if (lpofn->lpstrCustomFilter) {

  00344	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00347	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0034b	74 3c		 je	 SHORT $L27144

; 86   :             response.fix(&selected->lpstrCustomFilter, selected->nMaxCustFilter * sizeof(char));

  0034d	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  00350	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00353	51		 push	 ecx
  00354	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  00357	83 c2 10	 add	 edx, 16			; 00000010H
  0035a	52		 push	 edx
  0035b	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  0035e	e8 00 00 00 00	 call	 ?fix@Message@@QAEXPAXI@Z ; Message::fix

; 87   :             if (selected->lpstrCustomFilter) {

  00363	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  00366	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0036a	74 1d		 je	 SHORT $L27144

; 88   :                 memcpy(lpofn->lpstrCustomFilter,
; 89   :                        selected->lpstrCustomFilter,
; 90   :                        lpofn->nMaxCustFilter * sizeof(char));

  0036c	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0036f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00372	51		 push	 ecx
  00373	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  00376	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00379	50		 push	 eax
  0037a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  0037d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00380	52		 push	 edx
  00381	e8 00 00 00 00	 call	 _memcpy
  00386	83 c4 0c	 add	 esp, 12			; 0000000cH
$L27144:

; 91   :             }
; 92   :         }
; 93   :         lpofn->nFilterIndex = selected->nFilterIndex;

  00389	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0038c	8b 4d bc	 mov	 ecx, DWORD PTR _selected$[ebp]
  0038f	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00392	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 94   :         if (lpofn->lpstrFile) {

  00395	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00398	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0039c	74 3c		 je	 SHORT $L27148

; 95   :             response.fix(&selected->lpstrFile, selected->nMaxFile * sizeof(char));

  0039e	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  003a1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003a4	51		 push	 ecx
  003a5	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  003a8	83 c2 1c	 add	 edx, 28			; 0000001cH
  003ab	52		 push	 edx
  003ac	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  003af	e8 00 00 00 00	 call	 ?fix@Message@@QAEXPAXI@Z ; Message::fix

; 96   :             if (selected->lpstrFile) {

  003b4	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  003b7	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  003bb	74 1d		 je	 SHORT $L27148

; 97   :                 memcpy(lpofn->lpstrFile, selected->lpstrFile, lpofn->nMaxFile * sizeof(char));

  003bd	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  003c0	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003c3	51		 push	 ecx
  003c4	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  003c7	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  003ca	50		 push	 eax
  003cb	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  003ce	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  003d1	52		 push	 edx
  003d2	e8 00 00 00 00	 call	 _memcpy
  003d7	83 c4 0c	 add	 esp, 12			; 0000000cH
$L27148:

; 98   :             }
; 99   :         }
; 100  :         if (lpofn->lpstrFileTitle) {

  003da	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  003dd	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  003e1	74 3c		 je	 SHORT $L27152

; 101  :             response.fix(&selected->lpstrFileTitle, selected->nMaxFileTitle * sizeof(char));

  003e3	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  003e6	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  003e9	51		 push	 ecx
  003ea	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  003ed	83 c2 24	 add	 edx, 36			; 00000024H
  003f0	52		 push	 edx
  003f1	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  003f4	e8 00 00 00 00	 call	 ?fix@Message@@QAEXPAXI@Z ; Message::fix

; 102  :             if (selected->lpstrFileTitle) {

  003f9	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  003fc	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00400	74 1d		 je	 SHORT $L27152

; 103  :                 memcpy(lpofn->lpstrFileTitle, selected->lpstrFileTitle, lpofn->nMaxFileTitle * sizeof(char));

  00402	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00405	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00408	51		 push	 ecx
  00409	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  0040c	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0040f	50		 push	 eax
  00410	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  00413	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00416	52		 push	 edx
  00417	e8 00 00 00 00	 call	 _memcpy
  0041c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L27152:

; 104  :             }
; 105  :         }
; 106  :         lpofn->Flags = selected->Flags;

  0041f	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00422	8b 4d bc	 mov	 ecx, DWORD PTR _selected$[ebp]
  00425	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00428	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 107  :         lpofn->nFileOffset = selected->nFileOffset;

  0042b	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0042e	8b 4d bc	 mov	 ecx, DWORD PTR _selected$[ebp]
  00431	66 8b 51 38	 mov	 dx, WORD PTR [ecx+56]
  00435	66 89 50 38	 mov	 WORD PTR [eax+56], dx

; 108  :         lpofn->nFileExtension = selected->nFileExtension;

  00439	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0043c	8b 4d bc	 mov	 ecx, DWORD PTR _selected$[ebp]
  0043f	66 8b 51 3a	 mov	 dx, WORD PTR [ecx+58]
  00443	66 89 50 3a	 mov	 WORD PTR [eax+58], dx
$L27143:

; 109  :     }
; 110  :     return NULL != selected;

  00447	33 c0		 xor	 eax, eax
  00449	83 7d bc 00	 cmp	 DWORD PTR _selected$[ebp], 0
  0044d	0f 95 c0	 setne	 al
  00450	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T28217[ebp], eax
  00456	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0045d	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  00460	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  00465	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T28217[ebp]

; 111  : }

  0046b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0046e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00475	5f		 pop	 edi
  00476	5e		 pop	 esi
  00477	5b		 pop	 ebx
  00478	8b e5		 mov	 esp, ebp
  0047a	5d		 pop	 ebp
  0047b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@@QAE@XZ	; Message::~Message
__ehhandler$?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z ENDP		; GetFileNameA
PUBLIC	??_C@_0BB@FJOKJKBI@GetOpenFileNameA?$AA@	; `string'
PUBLIC	?NewGetOpenFileNameA@@YGHPAUtagOFNA@@@Z		; NewGetOpenFileNameA
;	COMDAT ??_C@_0BB@FJOKJKBI@GetOpenFileNameA?$AA@
CONST	SEGMENT
??_C@_0BB@FJOKJKBI@GetOpenFileNameA?$AA@ DB 'GetOpenFileNameA', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?NewGetOpenFileNameA@@YGHPAUtagOFNA@@@Z
_TEXT	SEGMENT
_lpofn$ = 8						; size = 4
?NewGetOpenFileNameA@@YGHPAUtagOFNA@@@Z PROC NEAR	; NewGetOpenFileNameA, COMDAT

; 113  : BOOL WINAPI NewGetOpenFileNameA(LPOPENFILENAMEA lpofn) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 114  :     return GetFileNameA("GetOpenFileNameA", lpofn);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@FJOKJKBI@GetOpenFileNameA?$AA@
  00012	e8 00 00 00 00	 call	 ?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z ; GetFileNameA

; 115  : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?NewGetOpenFileNameA@@YGHPAUtagOFNA@@@Z ENDP		; NewGetOpenFileNameA
_TEXT	ENDS
PUBLIC	??_C@_0BB@CEJLPAEO@GetSaveFileNameA?$AA@	; `string'
PUBLIC	?NewGetSaveFileNameA@@YGHPAUtagOFNA@@@Z		; NewGetSaveFileNameA
;	COMDAT ??_C@_0BB@CEJLPAEO@GetSaveFileNameA?$AA@
CONST	SEGMENT
??_C@_0BB@CEJLPAEO@GetSaveFileNameA?$AA@ DB 'GetSaveFileNameA', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?NewGetSaveFileNameA@@YGHPAUtagOFNA@@@Z
_TEXT	SEGMENT
_lpofn$ = 8						; size = 4
?NewGetSaveFileNameA@@YGHPAUtagOFNA@@@Z PROC NEAR	; NewGetSaveFileNameA, COMDAT

; 117  : BOOL WINAPI NewGetSaveFileNameA(LPOPENFILENAMEA lpofn) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 118  :     return GetFileNameA("GetSaveFileNameA", lpofn);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@CEJLPAEO@GetSaveFileNameA?$AA@
  00012	e8 00 00 00 00	 call	 ?GetFileNameA@@YGHPBDPAUtagOFNA@@@Z ; GetFileNameA

; 119  : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?NewGetSaveFileNameA@@YGHPAUtagOFNA@@@Z ENDP		; NewGetSaveFileNameA
_TEXT	ENDS
PUBLIC	?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z		; GetFileNameW
EXTRN	_wcslen:NEAR
EXTRN	?promise@Serializer@@QAEXPBG@Z:NEAR		; Serializer::promise
EXTRN	?send@Serializer@@QAEXPBG@Z:NEAR		; Serializer::send
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z$0
__ehfuncinfo$?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /ZI
xdata$x	ENDS
;	COMDAT ?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z
_TEXT	SEGMENT
$T28238 = -136						; size = 4
_selected$ = -68					; size = 4
_response$ = -64					; size = 20
_FlagsEx$27192 = -44					; size = 4
_dwReserved$27191 = -40					; size = 4
_pvReserved$27190 = -36					; size = 4
_last$27178 = -32					; size = 4
_first$27177 = -28					; size = 4
_lpstrFilter_length$ = -24				; size = 4
_request$ = -20						; size = 4
_sentStructSize$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_method_name$ = 8					; size = 4
_lpofn$ = 12						; size = 4
?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z PROC NEAR		; GetFileNameW, COMDAT

; 121  : BOOL WINAPI GetFileNameW(const char* method_name, LPOPENFILENAMEW lpofn) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 7c	 sub	 esp, 124		; 0000007cH
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 122  : 
; 123  :     // We only know how to send stuff we understand and should only send stuff the client understands.
; 124  :     DWORD sentStructSize = lpofn->lStructSize;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d f0	 mov	 DWORD PTR _sentStructSize$[ebp], ecx

; 125  :     if (sizeof(OPENFILENAMEW) < sentStructSize) {

  00026	83 7d f0 58	 cmp	 DWORD PTR _sentStructSize$[ebp], 88 ; 00000058H
  0002a	76 07		 jbe	 SHORT $L27171

; 126  :         sentStructSize = sizeof(OPENFILENAMEW);

  0002c	c7 45 f0 58 00
	00 00		 mov	 DWORD PTR _sentStructSize$[ebp], 88 ; 00000058H
$L27171:

; 127  :     }
; 128  :     Request* request = client->initiate(method_name, sizeof(OPENFILENAMEW));

  00033	6a 58		 push	 88			; 00000058H
  00035	8b 45 08	 mov	 eax, DWORD PTR _method_name$[ebp]
  00038	50		 push	 eax
  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?client@@3PAVRPCClient@@A ; client
  0003f	e8 00 00 00 00	 call	 ?initiate@RPCClient@@QAEPAVRequest@@PBDI@Z ; RPCClient::initiate
  00044	89 45 ec	 mov	 DWORD PTR _request$[ebp], eax

; 129  :     request->send(&sentStructSize, sizeof sentStructSize);

  00047	6a 04		 push	 4
  00049	8d 45 f0	 lea	 eax, DWORD PTR _sentStructSize$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00050	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 130  :     request->send(&lpofn->hwndOwner, sizeof lpofn->hwndOwner);

  00055	6a 04		 push	 4
  00057	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0005a	83 c0 04	 add	 eax, 4
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00061	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 131  :     request->send(&lpofn->hInstance, sizeof lpofn->hInstance);

  00066	6a 04		 push	 4
  00068	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0006b	83 c0 08	 add	 eax, 8
  0006e	50		 push	 eax
  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00072	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 132  :     size_t lpstrFilter_length;
; 133  :     if (lpofn->lpstrFilter) {

  00077	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0007a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0007e	74 5b		 je	 SHORT $L27176

; 134  :         const wchar_t* first = lpofn->lpstrFilter;

  00080	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00083	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00086	89 4d e4	 mov	 DWORD PTR _first$27177[ebp], ecx

; 135  :         const wchar_t* last = first;

  00089	8b 45 e4	 mov	 eax, DWORD PTR _first$27177[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR _last$27178[ebp], eax
$L27179:

; 136  :         do {
; 137  :             last += wcslen(last) + 1;

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _last$27178[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _wcslen
  00098	83 c4 04	 add	 esp, 4
  0009b	8b 4d e0	 mov	 ecx, DWORD PTR _last$27178[ebp]
  0009e	8d 54 41 02	 lea	 edx, DWORD PTR [ecx+eax*2+2]
  000a2	89 55 e0	 mov	 DWORD PTR _last$27178[ebp], edx

; 138  :             last += wcslen(last) + 1;

  000a5	8b 45 e0	 mov	 eax, DWORD PTR _last$27178[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 _wcslen
  000ae	83 c4 04	 add	 esp, 4
  000b1	8b 4d e0	 mov	 ecx, DWORD PTR _last$27178[ebp]
  000b4	8d 54 41 02	 lea	 edx, DWORD PTR [ecx+eax*2+2]
  000b8	89 55 e0	 mov	 DWORD PTR _last$27178[ebp], edx

; 139  :         } while(*last != L'\0');

  000bb	8b 45 e0	 mov	 eax, DWORD PTR _last$27178[ebp]
  000be	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000c1	85 c9		 test	 ecx, ecx
  000c3	75 ca		 jne	 SHORT $L27179

; 140  :         ++last;

  000c5	8b 45 e0	 mov	 eax, DWORD PTR _last$27178[ebp]
  000c8	83 c0 02	 add	 eax, 2
  000cb	89 45 e0	 mov	 DWORD PTR _last$27178[ebp], eax

; 141  :         lpstrFilter_length = last - first;

  000ce	8b 45 e0	 mov	 eax, DWORD PTR _last$27178[ebp]
  000d1	2b 45 e4	 sub	 eax, DWORD PTR _first$27177[ebp]
  000d4	d1 f8		 sar	 eax, 1
  000d6	89 45 e8	 mov	 DWORD PTR _lpstrFilter_length$[ebp], eax

; 142  :     } else {

  000d9	eb 07		 jmp	 SHORT $L27182
$L27176:

; 143  :         lpstrFilter_length = 0;

  000db	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _lpstrFilter_length$[ebp], 0
$L27182:

; 144  :     }
; 145  :     request->promise(lpofn->lpstrFilter, lpstrFilter_length * sizeof(wchar_t));

  000e2	8b 45 e8	 mov	 eax, DWORD PTR _lpstrFilter_length$[ebp]
  000e5	d1 e0		 shl	 eax, 1
  000e7	50		 push	 eax
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  000eb	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000ee	52		 push	 edx
  000ef	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  000f2	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBXI@Z ; Serializer::promise

; 146  :     request->promise(lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter * sizeof(wchar_t));

  000f7	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  000fa	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000fd	d1 e1		 shl	 ecx, 1
  000ff	51		 push	 ecx
  00100	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  00103	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00106	50		 push	 eax
  00107	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0010a	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBXI@Z ; Serializer::promise

; 147  :     request->send(&lpofn->nMaxCustFilter, sizeof lpofn->nMaxCustFilter);

  0010f	6a 04		 push	 4
  00111	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00114	83 c0 14	 add	 eax, 20			; 00000014H
  00117	50		 push	 eax
  00118	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0011b	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 148  :     request->send(&lpofn->nFilterIndex, sizeof lpofn->nFilterIndex);

  00120	6a 04		 push	 4
  00122	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00125	83 c0 18	 add	 eax, 24			; 00000018H
  00128	50		 push	 eax
  00129	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0012c	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 149  :     request->promise(lpofn->lpstrFile, lpofn->nMaxFile * sizeof(wchar_t));

  00131	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00134	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00137	d1 e1		 shl	 ecx, 1
  00139	51		 push	 ecx
  0013a	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  0013d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00140	50		 push	 eax
  00141	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00144	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBXI@Z ; Serializer::promise

; 150  :     request->send(&lpofn->nMaxFile, sizeof lpofn->nMaxFile);

  00149	6a 04		 push	 4
  0014b	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0014e	83 c0 20	 add	 eax, 32			; 00000020H
  00151	50		 push	 eax
  00152	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00155	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 151  :     request->promise(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle * sizeof(wchar_t));

  0015a	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0015d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00160	d1 e1		 shl	 ecx, 1
  00162	51		 push	 ecx
  00163	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  00166	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00169	50		 push	 eax
  0016a	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0016d	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBXI@Z ; Serializer::promise

; 152  :     request->send(&lpofn->nMaxFileTitle, sizeof lpofn->nMaxFileTitle);

  00172	6a 04		 push	 4
  00174	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00177	83 c0 28	 add	 eax, 40			; 00000028H
  0017a	50		 push	 eax
  0017b	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0017e	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 153  :     request->promise(lpofn->lpstrInitialDir);

  00183	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00186	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00189	51		 push	 ecx
  0018a	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0018d	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBG@Z ; Serializer::promise

; 154  :     request->promise(lpofn->lpstrTitle);

  00192	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00195	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00198	51		 push	 ecx
  00199	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0019c	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBG@Z ; Serializer::promise

; 155  :     request->send(&lpofn->Flags, sizeof lpofn->Flags);

  001a1	6a 04		 push	 4
  001a3	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001a6	83 c0 34	 add	 eax, 52			; 00000034H
  001a9	50		 push	 eax
  001aa	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001ad	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 156  :     request->send(&lpofn->nFileOffset, sizeof lpofn->nFileOffset);

  001b2	6a 02		 push	 2
  001b4	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001b7	83 c0 38	 add	 eax, 56			; 00000038H
  001ba	50		 push	 eax
  001bb	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001be	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 157  :     request->send(&lpofn->nFileExtension, sizeof lpofn->nFileExtension);

  001c3	6a 02		 push	 2
  001c5	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001c8	83 c0 3a	 add	 eax, 58			; 0000003aH
  001cb	50		 push	 eax
  001cc	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001cf	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 158  :     request->promise(lpofn->lpstrDefExt);

  001d4	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001d7	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  001da	51		 push	 ecx
  001db	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001de	e8 00 00 00 00	 call	 ?promise@Serializer@@QAEXPBG@Z ; Serializer::promise

; 159  :     request->send(&lpofn->lCustData, sizeof lpofn->lCustData);

  001e3	6a 04		 push	 4
  001e5	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001e8	83 c0 40	 add	 eax, 64			; 00000040H
  001eb	50		 push	 eax
  001ec	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  001ef	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 160  :     request->send(&lpofn->lpfnHook, sizeof lpofn->lpfnHook);

  001f4	6a 04		 push	 4
  001f6	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  001f9	83 c0 44	 add	 eax, 68			; 00000044H
  001fc	50		 push	 eax
  001fd	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00200	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 161  :     request->send(&lpofn->lpTemplateName, sizeof lpofn->lpTemplateName);

  00205	6a 04		 push	 4
  00207	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0020a	83 c0 48	 add	 eax, 72			; 00000048H
  0020d	50		 push	 eax
  0020e	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00211	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 162  :     if (sentStructSize == sizeof(OPENFILENAMEW)) {

  00216	83 7d f0 58	 cmp	 DWORD PTR _sentStructSize$[ebp], 88 ; 00000058H
  0021a	75 35		 jne	 SHORT $L27188

; 163  :         request->send(&lpofn->pvReserved, sizeof lpofn->pvReserved);

  0021c	6a 04		 push	 4
  0021e	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00221	83 c0 4c	 add	 eax, 76			; 0000004cH
  00224	50		 push	 eax
  00225	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00228	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 164  :         request->send(&lpofn->dwReserved, sizeof lpofn->dwReserved);

  0022d	6a 04		 push	 4
  0022f	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00232	83 c0 50	 add	 eax, 80			; 00000050H
  00235	50		 push	 eax
  00236	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00239	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 165  :         request->send(&lpofn->FlagsEx, sizeof lpofn->FlagsEx);

  0023e	6a 04		 push	 4
  00240	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00243	83 c0 54	 add	 eax, 84			; 00000054H
  00246	50		 push	 eax
  00247	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0024a	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 166  :     } else {

  0024f	eb 3f		 jmp	 SHORT $L27189
$L27188:

; 167  :         void* pvReserved = 0;

  00251	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _pvReserved$27190[ebp], 0

; 168  :         DWORD dwReserved = 0;

  00258	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _dwReserved$27191[ebp], 0

; 169  :         DWORD FlagsEx = 0;

  0025f	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _FlagsEx$27192[ebp], 0

; 170  :         request->send(&pvReserved, sizeof pvReserved);

  00266	6a 04		 push	 4
  00268	8d 45 dc	 lea	 eax, DWORD PTR _pvReserved$27190[ebp]
  0026b	50		 push	 eax
  0026c	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0026f	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 171  :         request->send(&dwReserved, sizeof dwReserved);

  00274	6a 04		 push	 4
  00276	8d 45 d8	 lea	 eax, DWORD PTR _dwReserved$27191[ebp]
  00279	50		 push	 eax
  0027a	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0027d	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 172  :         request->send(&FlagsEx, sizeof FlagsEx);

  00282	6a 04		 push	 4
  00284	8d 45 d4	 lea	 eax, DWORD PTR _FlagsEx$27192[ebp]
  00287	50		 push	 eax
  00288	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0028b	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send
$L27189:

; 173  :     }
; 174  : 
; 175  :     request->send(lpofn->lpstrFilter, lpstrFilter_length * sizeof(wchar_t));

  00290	8b 45 e8	 mov	 eax, DWORD PTR _lpstrFilter_length$[ebp]
  00293	d1 e0		 shl	 eax, 1
  00295	50		 push	 eax
  00296	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  00299	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0029c	52		 push	 edx
  0029d	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002a0	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 176  :     request->send(lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter * sizeof(wchar_t));

  002a5	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002a8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002ab	d1 e1		 shl	 ecx, 1
  002ad	51		 push	 ecx
  002ae	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  002b1	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  002b4	50		 push	 eax
  002b5	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002b8	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 177  :     request->send(lpofn->lpstrFile, lpofn->nMaxFile * sizeof(wchar_t));

  002bd	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002c0	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  002c3	d1 e1		 shl	 ecx, 1
  002c5	51		 push	 ecx
  002c6	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  002c9	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  002cc	50		 push	 eax
  002cd	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002d0	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 178  :     request->send(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle * sizeof(wchar_t));

  002d5	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002d8	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  002db	d1 e1		 shl	 ecx, 1
  002dd	51		 push	 ecx
  002de	8b 55 0c	 mov	 edx, DWORD PTR _lpofn$[ebp]
  002e1	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  002e4	50		 push	 eax
  002e5	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002e8	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 179  :     request->send(lpofn->lpstrInitialDir);

  002ed	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002f0	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  002f3	51		 push	 ecx
  002f4	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  002f7	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBG@Z ; Serializer::send

; 180  :     request->send(lpofn->lpstrTitle);

  002fc	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  002ff	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00302	51		 push	 ecx
  00303	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00306	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBG@Z ; Serializer::send

; 181  :     request->send(lpofn->lpstrDefExt);

  0030b	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0030e	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00311	51		 push	 ecx
  00312	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00315	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBG@Z ; Serializer::send

; 182  : 
; 183  :     Message response = request->finish(true, 60 * 60 * 24);

  0031a	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@40f5180000000000
  00320	83 ec 08	 sub	 esp, 8
  00323	dd 1c 24	 fstp	 QWORD PTR [esp]
  00326	6a 01		 push	 1
  00328	8d 45 c0	 lea	 eax, DWORD PTR _response$[ebp]
  0032b	50		 push	 eax
  0032c	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  0032f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00331	8b 4d ec	 mov	 ecx, DWORD PTR _request$[ebp]
  00334	ff 52 04	 call	 DWORD PTR [edx+4]
  00337	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 184  :     LPOPENFILENAMEW selected;
; 185  :     response.cast(&selected, sizeof(OPENFILENAMEW));

  0033e	6a 58		 push	 88			; 00000058H
  00340	8d 45 bc	 lea	 eax, DWORD PTR _selected$[ebp]
  00343	50		 push	 eax
  00344	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  00347	e8 00 00 00 00	 call	 ?cast@Message@@QAEXPAXI@Z ; Message::cast

; 186  :     if (selected) {

  0034c	83 7d bc 00	 cmp	 DWORD PTR _selected$[ebp], 0
  00350	0f 84 0f 01 00
	00		 je	 $L27201

; 187  :         if (lpofn->lpstrCustomFilter) {

  00356	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00359	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0035d	74 40		 je	 SHORT $L27202

; 188  :             response.fix(&selected->lpstrCustomFilter, selected->nMaxCustFilter * sizeof(wchar_t));

  0035f	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  00362	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00365	d1 e1		 shl	 ecx, 1
  00367	51		 push	 ecx
  00368	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  0036b	83 c2 10	 add	 edx, 16			; 00000010H
  0036e	52		 push	 edx
  0036f	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  00372	e8 00 00 00 00	 call	 ?fix@Message@@QAEXPAXI@Z ; Message::fix

; 189  :             if (selected->lpstrCustomFilter) {

  00377	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  0037a	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0037e	74 1f		 je	 SHORT $L27202

; 190  :                 memcpy(lpofn->lpstrCustomFilter,
; 191  :                        selected->lpstrCustomFilter,
; 192  :                        lpofn->nMaxCustFilter * sizeof(wchar_t));

  00380	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00383	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00386	d1 e1		 shl	 ecx, 1
  00388	51		 push	 ecx
  00389	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  0038c	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0038f	50		 push	 eax
  00390	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  00393	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00396	52		 push	 edx
  00397	e8 00 00 00 00	 call	 _memcpy
  0039c	83 c4 0c	 add	 esp, 12			; 0000000cH
$L27202:

; 193  :             }
; 194  :         }
; 195  :         lpofn->nFilterIndex = selected->nFilterIndex;

  0039f	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  003a2	8b 4d bc	 mov	 ecx, DWORD PTR _selected$[ebp]
  003a5	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  003a8	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 196  :         if (lpofn->lpstrFile) {

  003ab	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  003ae	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  003b2	74 40		 je	 SHORT $L27206

; 197  :             response.fix(&selected->lpstrFile, selected->nMaxFile * sizeof(wchar_t));

  003b4	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  003b7	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003ba	d1 e1		 shl	 ecx, 1
  003bc	51		 push	 ecx
  003bd	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  003c0	83 c2 1c	 add	 edx, 28			; 0000001cH
  003c3	52		 push	 edx
  003c4	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  003c7	e8 00 00 00 00	 call	 ?fix@Message@@QAEXPAXI@Z ; Message::fix

; 198  :             if (selected->lpstrFile) {

  003cc	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  003cf	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  003d3	74 1f		 je	 SHORT $L27206

; 199  :                 memcpy(lpofn->lpstrFile, selected->lpstrFile, lpofn->nMaxFile * sizeof(wchar_t));

  003d5	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  003d8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  003db	d1 e1		 shl	 ecx, 1
  003dd	51		 push	 ecx
  003de	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  003e1	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  003e4	50		 push	 eax
  003e5	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  003e8	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  003eb	52		 push	 edx
  003ec	e8 00 00 00 00	 call	 _memcpy
  003f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$L27206:

; 200  :             }
; 201  :         }
; 202  :         if (lpofn->lpstrFileTitle) {

  003f4	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  003f7	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  003fb	74 40		 je	 SHORT $L27210

; 203  :             response.fix(&selected->lpstrFileTitle, selected->nMaxFileTitle * sizeof(wchar_t));

  003fd	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  00400	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00403	d1 e1		 shl	 ecx, 1
  00405	51		 push	 ecx
  00406	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  00409	83 c2 24	 add	 edx, 36			; 00000024H
  0040c	52		 push	 edx
  0040d	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  00410	e8 00 00 00 00	 call	 ?fix@Message@@QAEXPAXI@Z ; Message::fix

; 204  :             if (selected->lpstrFileTitle) {

  00415	8b 45 bc	 mov	 eax, DWORD PTR _selected$[ebp]
  00418	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0041c	74 1f		 je	 SHORT $L27210

; 205  :                 memcpy(lpofn->lpstrFileTitle, selected->lpstrFileTitle, lpofn->nMaxFileTitle * sizeof(wchar_t));

  0041e	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00421	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00424	d1 e1		 shl	 ecx, 1
  00426	51		 push	 ecx
  00427	8b 55 bc	 mov	 edx, DWORD PTR _selected$[ebp]
  0042a	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0042d	50		 push	 eax
  0042e	8b 4d 0c	 mov	 ecx, DWORD PTR _lpofn$[ebp]
  00431	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00434	52		 push	 edx
  00435	e8 00 00 00 00	 call	 _memcpy
  0043a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L27210:

; 206  :             }
; 207  :         }
; 208  :         lpofn->Flags = selected->Flags;

  0043d	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  00440	8b 4d bc	 mov	 ecx, DWORD PTR _selected$[ebp]
  00443	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00446	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 209  :         lpofn->nFileOffset = selected->nFileOffset;

  00449	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0044c	8b 4d bc	 mov	 ecx, DWORD PTR _selected$[ebp]
  0044f	66 8b 51 38	 mov	 dx, WORD PTR [ecx+56]
  00453	66 89 50 38	 mov	 WORD PTR [eax+56], dx

; 210  :         lpofn->nFileExtension = selected->nFileExtension;

  00457	8b 45 0c	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0045a	8b 4d bc	 mov	 ecx, DWORD PTR _selected$[ebp]
  0045d	66 8b 51 3a	 mov	 dx, WORD PTR [ecx+58]
  00461	66 89 50 3a	 mov	 WORD PTR [eax+58], dx
$L27201:

; 211  :     }
; 212  :     return NULL != selected;

  00465	33 c0		 xor	 eax, eax
  00467	83 7d bc 00	 cmp	 DWORD PTR _selected$[ebp], 0
  0046b	0f 95 c0	 setne	 al
  0046e	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T28238[ebp], eax
  00474	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0047b	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  0047e	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  00483	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T28238[ebp]

; 213  : }

  00489	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0048c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00493	5f		 pop	 edi
  00494	5e		 pop	 esi
  00495	5b		 pop	 ebx
  00496	8b e5		 mov	 esp, ebp
  00498	5d		 pop	 ebp
  00499	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _response$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@@QAE@XZ	; Message::~Message
__ehhandler$?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z ENDP		; GetFileNameW
PUBLIC	??_C@_0BB@EFHCCPMP@GetOpenFileNameW?$AA@	; `string'
PUBLIC	?NewGetOpenFileNameW@@YGHPAUtagOFNW@@@Z		; NewGetOpenFileNameW
;	COMDAT ??_C@_0BB@EFHCCPMP@GetOpenFileNameW?$AA@
CONST	SEGMENT
??_C@_0BB@EFHCCPMP@GetOpenFileNameW?$AA@ DB 'GetOpenFileNameW', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?NewGetOpenFileNameW@@YGHPAUtagOFNW@@@Z
_TEXT	SEGMENT
_lpofn$ = 8						; size = 4
?NewGetOpenFileNameW@@YGHPAUtagOFNW@@@Z PROC NEAR	; NewGetOpenFileNameW, COMDAT

; 215  : BOOL WINAPI NewGetOpenFileNameW(LPOPENFILENAMEW lpofn) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 216  :     return GetFileNameW("GetOpenFileNameW", lpofn);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@EFHCCPMP@GetOpenFileNameW?$AA@
  00012	e8 00 00 00 00	 call	 ?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z ; GetFileNameW

; 217  : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?NewGetOpenFileNameW@@YGHPAUtagOFNW@@@Z ENDP		; NewGetOpenFileNameW
_TEXT	ENDS
PUBLIC	??_C@_0BB@DIADEFJJ@GetSaveFileNameW?$AA@	; `string'
PUBLIC	?NewGetSaveFileNameW@@YGHPAUtagOFNW@@@Z		; NewGetSaveFileNameW
;	COMDAT ??_C@_0BB@DIADEFJJ@GetSaveFileNameW?$AA@
CONST	SEGMENT
??_C@_0BB@DIADEFJJ@GetSaveFileNameW?$AA@ DB 'GetSaveFileNameW', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?NewGetSaveFileNameW@@YGHPAUtagOFNW@@@Z
_TEXT	SEGMENT
_lpofn$ = 8						; size = 4
?NewGetSaveFileNameW@@YGHPAUtagOFNW@@@Z PROC NEAR	; NewGetSaveFileNameW, COMDAT

; 219  : BOOL WINAPI NewGetSaveFileNameW(LPOPENFILENAMEW lpofn) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 220  :     return GetFileNameW("GetSaveFileNameW", lpofn);

  00009	8b 45 08	 mov	 eax, DWORD PTR _lpofn$[ebp]
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@DIADEFJJ@GetSaveFileNameW?$AA@
  00012	e8 00 00 00 00	 call	 ?GetFileNameW@@YGHPBDPAUtagOFNW@@@Z ; GetFileNameW

; 221  : }

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?NewGetSaveFileNameW@@YGHPAUtagOFNW@@@Z ENDP		; NewGetSaveFileNameW
_TEXT	ENDS
PUBLIC	__real@4008000000000000
PUBLIC	?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ; std::vector<void *,std::allocator<void *> >::push_back
PUBLIC	?NewGetClipboardData@@YGPAXI@Z			; NewGetClipboardData
PUBLIC	??_C@_0BB@MFFIAPJA@GetClipboardData?$AA@	; `string'
PUBLIC	??_C@_0P@GJGAPMJD@CloseClipboard?$AA@		; `string'
EXTRN	__imp__GlobalAlloc@8:NEAR
EXTRN	__imp__GlobalLock@4:NEAR
EXTRN	__imp__GlobalUnlock@4:NEAR
EXTRN	__imp__GlobalFree@4:NEAR
EXTRN	__imp__GetLastError@0:NEAR
EXTRN	__imp__SetLastError@4:NEAR
EXTRN	__imp__OpenClipboard@4:NEAR
EXTRN	__imp__GetOpenClipboardWindow@0:NEAR
EXTRN	?HookGetOriginal@@YAPAXPBD@Z:NEAR		; HookGetOriginal
EXTRN	?length@Message@@QBEIXZ:NEAR			; Message::length
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?NewGetClipboardData@@YGPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewGetClipboardData@@YGPAXI@Z$0
__ehfuncinfo$?NewGetClipboardData@@YGPAXI@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?NewGetClipboardData@@YGPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BB@MFFIAPJA@GetClipboardData?$AA@
CONST	SEGMENT
??_C@_0BB@MFFIAPJA@GetClipboardData?$AA@ DB 'GetClipboardData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GJGAPMJD@CloseClipboard?$AA@
CONST	SEGMENT
??_C@_0P@GJGAPMJD@CloseClipboard?$AA@ DB 'CloseClipboard', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?NewGetClipboardData@@YGPAXI@Z
_TEXT	SEGMENT
$T28252 = -132						; size = 4
_data$27495 = -64					; size = 4
_ptr$27493 = -60					; size = 4
_handle$27491 = -56					; size = 4
_data_size$27489 = -52					; size = 4
_response$27487 = -48					; size = 20
_request$27485 = -28					; size = 4
_owner$27482 = -24					; size = 4
_original_error$27481 = -20				; size = 4
_result$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_format$ = 8						; size = 4
?NewGetClipboardData@@YGPAXI@Z PROC NEAR		; NewGetClipboardData, COMDAT

; 225  : HANDLE WINAPI NewGetClipboardData(UINT format) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?NewGetClipboardData@@YGPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 78	 sub	 esp, 120		; 00000078H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 226  :     HANDLE result = ORIGINAL(GetClipboardData)(format);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MFFIAPJA@GetClipboardData?$AA@
  00027	e8 00 00 00 00	 call	 ?HookGetOriginal@@YAPAXPBD@Z ; HookGetOriginal
  0002c	83 c4 04	 add	 esp, 4
  0002f	ff d0		 call	 eax
  00031	89 45 f0	 mov	 DWORD PTR _result$[ebp], eax

; 227  :     if (NULL == result) {

  00034	83 7d f0 00	 cmp	 DWORD PTR _result$[ebp], 0
  00038	0f 85 54 01 00
	00		 jne	 $L27480

; 228  :         DWORD original_error = GetLastError();

  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00044	89 45 ec	 mov	 DWORD PTR _original_error$27481[ebp], eax

; 229  : 
; 230  :         HWND owner = GetOpenClipboardWindow();

  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetOpenClipboardWindow@0
  0004d	89 45 e8	 mov	 DWORD PTR _owner$27482[ebp], eax

; 231  :         ORIGINAL(CloseClipboard)();

  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@GJGAPMJD@CloseClipboard?$AA@
  00055	e8 00 00 00 00	 call	 ?HookGetOriginal@@YAPAXPBD@Z ; HookGetOriginal
  0005a	83 c4 04	 add	 esp, 4
  0005d	ff d0		 call	 eax

; 232  :         Request* request = client->initiate("GetClipboardData", sizeof(GetClipboardDataParameters));

  0005f	6a 08		 push	 8
  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MFFIAPJA@GetClipboardData?$AA@
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?client@@3PAVRPCClient@@A ; client
  0006c	e8 00 00 00 00	 call	 ?initiate@RPCClient@@QAEPAVRequest@@PBDI@Z ; RPCClient::initiate
  00071	89 45 e4	 mov	 DWORD PTR _request$27485[ebp], eax

; 233  :         request->send(&owner, sizeof owner);

  00074	6a 04		 push	 4
  00076	8d 45 e8	 lea	 eax, DWORD PTR _owner$27482[ebp]
  00079	50		 push	 eax
  0007a	8b 4d e4	 mov	 ecx, DWORD PTR _request$27485[ebp]
  0007d	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 234  :         request->send(&format, sizeof format);

  00082	6a 04		 push	 4
  00084	8d 45 08	 lea	 eax, DWORD PTR _format$[ebp]
  00087	50		 push	 eax
  00088	8b 4d e4	 mov	 ecx, DWORD PTR _request$27485[ebp]
  0008b	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 235  :         Message response = request->finish(false, 3);

  00090	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4008000000000000
  00096	83 ec 08	 sub	 esp, 8
  00099	dd 1c 24	 fstp	 QWORD PTR [esp]
  0009c	6a 00		 push	 0
  0009e	8d 45 d0	 lea	 eax, DWORD PTR _response$27487[ebp]
  000a1	50		 push	 eax
  000a2	8b 4d e4	 mov	 ecx, DWORD PTR _request$27485[ebp]
  000a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR _request$27485[ebp]
  000aa	ff 52 04	 call	 DWORD PTR [edx+4]
  000ad	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 236  :         OpenClipboard(owner);

  000b4	8b 45 e8	 mov	 eax, DWORD PTR _owner$27482[ebp]
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenClipboard@4

; 237  :         size_t data_size = response.length();

  000be	8d 4d d0	 lea	 ecx, DWORD PTR _response$27487[ebp]
  000c1	e8 00 00 00 00	 call	 ?length@Message@@QBEIXZ	; Message::length
  000c6	89 45 cc	 mov	 DWORD PTR _data_size$27489[ebp], eax

; 238  :         if (data_size != 0) {

  000c9	83 7d cc 00	 cmp	 DWORD PTR _data_size$27489[ebp], 0
  000cd	0f 84 a6 00 00
	00		 je	 $L27490

; 239  :             HGLOBAL handle = GlobalAlloc(GMEM_MOVEABLE, data_size);

  000d3	8b 45 cc	 mov	 eax, DWORD PTR _data_size$27489[ebp]
  000d6	50		 push	 eax
  000d7	6a 02		 push	 2
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  000df	89 45 c8	 mov	 DWORD PTR _handle$27491[ebp], eax

; 240  :             if (handle) {

  000e2	83 7d c8 00	 cmp	 DWORD PTR _handle$27491[ebp], 0
  000e6	0f 84 8d 00 00
	00		 je	 $L27490

; 241  :                 void* ptr = GlobalLock(handle);

  000ec	8b 45 c8	 mov	 eax, DWORD PTR _handle$27491[ebp]
  000ef	50		 push	 eax
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  000f6	89 45 c4	 mov	 DWORD PTR _ptr$27493[ebp], eax

; 242  :                 if (ptr) {

  000f9	83 7d c4 00	 cmp	 DWORD PTR _ptr$27493[ebp], 0
  000fd	74 70		 je	 SHORT $L27494

; 243  :                     void* data;
; 244  :                     response.cast(&data, data_size);

  000ff	8b 45 cc	 mov	 eax, DWORD PTR _data_size$27489[ebp]
  00102	50		 push	 eax
  00103	8d 4d c0	 lea	 ecx, DWORD PTR _data$27495[ebp]
  00106	51		 push	 ecx
  00107	8d 4d d0	 lea	 ecx, DWORD PTR _response$27487[ebp]
  0010a	e8 00 00 00 00	 call	 ?cast@Message@@QAEXPAXI@Z ; Message::cast

; 245  :                     memcpy(ptr, data, data_size);

  0010f	8b 45 cc	 mov	 eax, DWORD PTR _data_size$27489[ebp]
  00112	50		 push	 eax
  00113	8b 4d c0	 mov	 ecx, DWORD PTR _data$27495[ebp]
  00116	51		 push	 ecx
  00117	8b 55 c4	 mov	 edx, DWORD PTR _ptr$27493[ebp]
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 _memcpy
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH

; 246  :                     GlobalUnlock(handle);

  00123	8b 45 c8	 mov	 eax, DWORD PTR _handle$27491[ebp]
  00126	50		 push	 eax
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 247  :                     result = handle;

  0012d	8b 45 c8	 mov	 eax, DWORD PTR _handle$27491[ebp]
  00130	89 45 f0	 mov	 DWORD PTR _result$[ebp], eax

; 248  :                     if (result) {

  00133	83 7d f0 00	 cmp	 DWORD PTR _result$[ebp], 0
  00137	74 36		 je	 SHORT $L27494

; 249  :                         SetLastError(0);

  00139	6a 00		 push	 0
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 250  :                         open_handles.push_back(handle);

  00141	8d 45 c8	 lea	 eax, DWORD PTR _handle$27491[ebp]
  00144	50		 push	 eax
  00145	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?open_handles@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  0014a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ; std::vector<void *,std::allocator<void *> >::push_back

; 251  :                         return result;

  0014f	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
  00152	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T28252[ebp], eax
  00158	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0015f	8d 4d d0	 lea	 ecx, DWORD PTR _response$27487[ebp]
  00162	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  00167	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T28252[ebp]
  0016d	eb 26		 jmp	 SHORT $L27476
$L27494:

; 252  :                     }
; 253  :                 }
; 254  :                 GlobalFree(handle);

  0016f	8b 45 c8	 mov	 eax, DWORD PTR _handle$27491[ebp]
  00172	50		 push	 eax
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4
$L27490:

; 255  :             }
; 256  :         }
; 257  : 
; 258  :         SetLastError(original_error);

  00179	8b 45 ec	 mov	 eax, DWORD PTR _original_error$27481[ebp]
  0017c	50		 push	 eax
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 259  :     }

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8d 4d d0	 lea	 ecx, DWORD PTR _response$27487[ebp]
  0018d	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
$L27480:

; 260  :     return result;

  00192	8b 45 f0	 mov	 eax, DWORD PTR _result$[ebp]
$L27476:

; 261  : }

  00195	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00198	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0019f	5f		 pop	 edi
  001a0	5e		 pop	 esi
  001a1	5b		 pop	 ebx
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NewGetClipboardData@@YGPAXI@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _response$27487[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@@QAE@XZ	; Message::~Message
__ehhandler$?NewGetClipboardData@@YGPAXI@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?NewGetClipboardData@@YGPAXI@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NewGetClipboardData@@YGPAXI@Z ENDP			; NewGetClipboardData
PUBLIC	?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
PUBLIC	??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ; std::vector<void *,std::allocator<void *> >::operator[]
PUBLIC	?NewCloseClipboard@@YGHXZ			; NewCloseClipboard
PUBLIC	?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ ; std::vector<void *,std::allocator<void *> >::clear
; Function compile flags: /Odt /ZI
;	COMDAT ?NewCloseClipboard@@YGHXZ
_TEXT	SEGMENT
_i$27502 = -8						; size = 4
_r$ = -4						; size = 4
?NewCloseClipboard@@YGHXZ PROC NEAR			; NewCloseClipboard, COMDAT

; 263  : BOOL WINAPI NewCloseClipboard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 264  :     BOOL r = ORIGINAL(CloseClipboard)();

  00009	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@GJGAPMJD@CloseClipboard?$AA@
  0000e	e8 00 00 00 00	 call	 ?HookGetOriginal@@YAPAXPBD@Z ; HookGetOriginal
  00013	83 c4 04	 add	 esp, 4
  00016	ff d0		 call	 eax
  00018	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 265  :     for (int i = open_handles.size(); i-- != 0;) {

  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?open_handles@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00020	e8 00 00 00 00	 call	 ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
  00025	89 45 f8	 mov	 DWORD PTR _i$27502[ebp], eax
$L27504:
  00028	8b 45 f8	 mov	 eax, DWORD PTR _i$27502[ebp]
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _i$27502[ebp]
  0002e	83 e9 01	 sub	 ecx, 1
  00031	89 4d f8	 mov	 DWORD PTR _i$27502[ebp], ecx
  00034	85 c0		 test	 eax, eax
  00036	74 19		 je	 SHORT $L27505

; 266  :         GlobalFree(open_handles[i]);

  00038	8b 45 f8	 mov	 eax, DWORD PTR _i$27502[ebp]
  0003b	50		 push	 eax
  0003c	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?open_handles@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00041	e8 00 00 00 00	 call	 ??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ; std::vector<void *,std::allocator<void *> >::operator[]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	51		 push	 ecx
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalFree@4

; 267  :     }

  0004f	eb d7		 jmp	 SHORT $L27504
$L27505:

; 268  :     open_handles.clear();

  00051	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?open_handles@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  00056	e8 00 00 00 00	 call	 ?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ ; std::vector<void *,std::allocator<void *> >::clear

; 269  :     return r;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]

; 270  : }

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?NewCloseClipboard@@YGHXZ ENDP				; NewCloseClipboard
_TEXT	ENDS
PUBLIC	?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z	; NewSetClipboardViewer
PUBLIC	??_C@_0BD@HMCBMPHP@SetClipboardViewer?$AA@	; `string'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z$0
__ehfuncinfo$?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@HMCBMPHP@SetClipboardViewer?$AA@
CONST	SEGMENT
??_C@_0BD@HMCBMPHP@SetClipboardViewer?$AA@ DB 'SetClipboardViewer', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z
_TEXT	SEGMENT
tv83 = -112						; size = 4
$T28266 = -108						; size = 4
_r$ = -40						; size = 4
_response$ = -36					; size = 20
_request$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hWndNewViewer$ = 8					; size = 4
?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z PROC NEAR	; NewSetClipboardViewer, COMDAT

; 272  : HWND WINAPI NewSetClipboardViewer(HWND hWndNewViewer) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 64	 sub	 esp, 100		; 00000064H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 273  :     Request* request = client->initiate("SetClipboardViewer", sizeof hWndNewViewer);

  0001e	6a 04		 push	 4
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@HMCBMPHP@SetClipboardViewer?$AA@
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?client@@3PAVRPCClient@@A ; client
  0002b	e8 00 00 00 00	 call	 ?initiate@RPCClient@@QAEPAVRequest@@PBDI@Z ; RPCClient::initiate
  00030	89 45 f0	 mov	 DWORD PTR _request$[ebp], eax

; 274  :     request->send(&hWndNewViewer, sizeof hWndNewViewer);

  00033	6a 04		 push	 4
  00035	8d 45 08	 lea	 eax, DWORD PTR _hWndNewViewer$[ebp]
  00038	50		 push	 eax
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _request$[ebp]
  0003c	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 275  :     Message response = request->finish(true, 3);

  00041	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4008000000000000
  00047	83 ec 08	 sub	 esp, 8
  0004a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0004d	6a 01		 push	 1
  0004f	8d 45 dc	 lea	 eax, DWORD PTR _response$[ebp]
  00052	50		 push	 eax
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _request$[ebp]
  00056	8b 11		 mov	 edx, DWORD PTR [ecx]
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _request$[ebp]
  0005b	ff 52 04	 call	 DWORD PTR [edx+4]
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 276  :     HWND* r;
; 277  :     response.cast(&r, sizeof(HWND));

  00065	6a 04		 push	 4
  00067	8d 45 d8	 lea	 eax, DWORD PTR _r$[ebp]
  0006a	50		 push	 eax
  0006b	8d 4d dc	 lea	 ecx, DWORD PTR _response$[ebp]
  0006e	e8 00 00 00 00	 call	 ?cast@Message@@QAEXPAXI@Z ; Message::cast

; 278  :     return r ? *r : NULL;

  00073	83 7d d8 00	 cmp	 DWORD PTR _r$[ebp], 0
  00077	74 0a		 je	 SHORT $L28267
  00079	8b 45 d8	 mov	 eax, DWORD PTR _r$[ebp]
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	89 4d 90	 mov	 DWORD PTR tv83[ebp], ecx
  00081	eb 07		 jmp	 SHORT $L28268
$L28267:
  00083	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$L28268:
  0008a	8b 55 90	 mov	 edx, DWORD PTR tv83[ebp]
  0008d	89 55 94	 mov	 DWORD PTR $T28266[ebp], edx
  00090	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8d 4d dc	 lea	 ecx, DWORD PTR _response$[ebp]
  0009a	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  0009f	8b 45 94	 mov	 eax, DWORD PTR $T28266[ebp]

; 279  : }

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _response$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@@QAE@XZ	; Message::~Message
__ehhandler$?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NewSetClipboardViewer@@YGPAUHWND__@@PAU1@@Z ENDP	; NewSetClipboardViewer
PUBLIC	?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z	; NewChangeClipboardChain
PUBLIC	??_C@_0BF@OMBCEPLE@ChangeClipboardChain?$AA@	; `string'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z$0
__ehfuncinfo$?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OMBCEPLE@ChangeClipboardChain?$AA@
CONST	SEGMENT
??_C@_0BF@OMBCEPLE@ChangeClipboardChain?$AA@ DB 'ChangeClipboardChain', 00H ; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z
_TEXT	SEGMENT
tv86 = -112						; size = 4
$T28278 = -108						; size = 4
_r$ = -40						; size = 4
_response$ = -36					; size = 20
_request$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hWndRemove$ = 8					; size = 4
_hWndNewNext$ = 12					; size = 4
?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z PROC NEAR	; NewChangeClipboardChain, COMDAT

; 281  : BOOL WINAPI NewChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 64	 sub	 esp, 100		; 00000064H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 282  :     Request* request = client->initiate("ChangeClipboardChain", sizeof ChangeClipboardChainParameters);

  0001e	6a 08		 push	 8
  00020	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BF@OMBCEPLE@ChangeClipboardChain?$AA@
  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?client@@3PAVRPCClient@@A ; client
  0002b	e8 00 00 00 00	 call	 ?initiate@RPCClient@@QAEPAVRequest@@PBDI@Z ; RPCClient::initiate
  00030	89 45 f0	 mov	 DWORD PTR _request$[ebp], eax

; 283  :     request->send(&hWndRemove, sizeof hWndRemove);

  00033	6a 04		 push	 4
  00035	8d 45 08	 lea	 eax, DWORD PTR _hWndRemove$[ebp]
  00038	50		 push	 eax
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _request$[ebp]
  0003c	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 284  :     request->send(&hWndNewNext, sizeof hWndNewNext);

  00041	6a 04		 push	 4
  00043	8d 45 0c	 lea	 eax, DWORD PTR _hWndNewNext$[ebp]
  00046	50		 push	 eax
  00047	8b 4d f0	 mov	 ecx, DWORD PTR _request$[ebp]
  0004a	e8 00 00 00 00	 call	 ?send@Serializer@@QAEXPBXI@Z ; Serializer::send

; 285  :     Message response = request->finish(true, 3);

  0004f	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4008000000000000
  00055	83 ec 08	 sub	 esp, 8
  00058	dd 1c 24	 fstp	 QWORD PTR [esp]
  0005b	6a 01		 push	 1
  0005d	8d 45 dc	 lea	 eax, DWORD PTR _response$[ebp]
  00060	50		 push	 eax
  00061	8b 4d f0	 mov	 ecx, DWORD PTR _request$[ebp]
  00064	8b 11		 mov	 edx, DWORD PTR [ecx]
  00066	8b 4d f0	 mov	 ecx, DWORD PTR _request$[ebp]
  00069	ff 52 04	 call	 DWORD PTR [edx+4]
  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 286  :     BOOL* r;
; 287  :     response.cast(&r, sizeof(BOOL));

  00073	6a 04		 push	 4
  00075	8d 45 d8	 lea	 eax, DWORD PTR _r$[ebp]
  00078	50		 push	 eax
  00079	8d 4d dc	 lea	 ecx, DWORD PTR _response$[ebp]
  0007c	e8 00 00 00 00	 call	 ?cast@Message@@QAEXPAXI@Z ; Message::cast

; 288  :     return r ? *r : FALSE;

  00081	83 7d d8 00	 cmp	 DWORD PTR _r$[ebp], 0
  00085	74 0a		 je	 SHORT $L28279
  00087	8b 45 d8	 mov	 eax, DWORD PTR _r$[ebp]
  0008a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008c	89 4d 90	 mov	 DWORD PTR tv86[ebp], ecx
  0008f	eb 07		 jmp	 SHORT $L28280
$L28279:
  00091	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$L28280:
  00098	8b 55 90	 mov	 edx, DWORD PTR tv86[ebp]
  0009b	89 55 94	 mov	 DWORD PTR $T28278[ebp], edx
  0009e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a5	8d 4d dc	 lea	 ecx, DWORD PTR _response$[ebp]
  000a8	e8 00 00 00 00	 call	 ??1Message@@QAE@XZ	; Message::~Message
  000ad	8b 45 94	 mov	 eax, DWORD PTR $T28278[ebp]

; 289  : }

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ba	5f		 pop	 edi
  000bb	5e		 pop	 esi
  000bc	5b		 pop	 ebx
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _response$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Message@@QAE@XZ	; Message::~Message
__ehhandler$?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?NewChangeClipboardChain@@YGHPAUHWND__@@0@Z ENDP	; NewChangeClipboardChain
PUBLIC	_ApplyHooks
PUBLIC	??_C@_08DNLJNOAA@comdlg32?$AA@			; `string'
PUBLIC	??_C@_06KMMDPPA@user32?$AA@			; `string'
EXTRN	?HookAddHook@@YAXPBD0PAX@Z:NEAR			; HookAddHook
EXTRN	?HookAddGetProcAddressHook@@YAXXZ:NEAR		; HookAddGetProcAddressHook
EXTRN	?HookAllLoadedAndFutureModules@@YAXXZ:NEAR	; HookAllLoadedAndFutureModules
;	COMDAT ??_C@_08DNLJNOAA@comdlg32?$AA@
CONST	SEGMENT
??_C@_08DNLJNOAA@comdlg32?$AA@ DB 'comdlg32', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMMDPPA@user32?$AA@
CONST	SEGMENT
??_C@_06KMMDPPA@user32?$AA@ DB 'user32', 00H		; `string'
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT _ApplyHooks
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
_ApplyHooks PROC NEAR					; COMDAT

; 293  : EXPORT size_t __cdecl ApplyHooks(BYTE*, size_t) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 294  : 	HookAddHook("comdlg32", "GetOpenFileNameA", NewGetOpenFileNameA);

  00009	68 00 00 00 00	 push	 OFFSET FLAT:?NewGetOpenFileNameA@@YGHPAUtagOFNA@@@Z ; NewGetOpenFileNameA
  0000e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@FJOKJKBI@GetOpenFileNameA?$AA@
  00013	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNLJNOAA@comdlg32?$AA@
  00018	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 295  : 	HookAddHook("comdlg32", "GetSaveFileNameA", NewGetSaveFileNameA);

  00020	68 00 00 00 00	 push	 OFFSET FLAT:?NewGetSaveFileNameA@@YGHPAUtagOFNA@@@Z ; NewGetSaveFileNameA
  00025	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@CEJLPAEO@GetSaveFileNameA?$AA@
  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNLJNOAA@comdlg32?$AA@
  0002f	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 296  : 	HookAddHook("comdlg32", "GetOpenFileNameW", NewGetOpenFileNameW);

  00037	68 00 00 00 00	 push	 OFFSET FLAT:?NewGetOpenFileNameW@@YGHPAUtagOFNW@@@Z ; NewGetOpenFileNameW
  0003c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@EFHCCPMP@GetOpenFileNameW?$AA@
  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNLJNOAA@comdlg32?$AA@
  00046	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  : 	HookAddHook("comdlg32", "GetSaveFileNameW", NewGetSaveFileNameW);

  0004e	68 00 00 00 00	 push	 OFFSET FLAT:?NewGetSaveFileNameW@@YGHPAUtagOFNW@@@Z ; NewGetSaveFileNameW
  00053	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@DIADEFJJ@GetSaveFileNameW?$AA@
  00058	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08DNLJNOAA@comdlg32?$AA@
  0005d	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 298  : 	HookAddHook("user32", "GetClipboardData", NewGetClipboardData);

  00065	68 00 00 00 00	 push	 OFFSET FLAT:?NewGetClipboardData@@YGPAXI@Z ; NewGetClipboardData
  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BB@MFFIAPJA@GetClipboardData?$AA@
  0006f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06KMMDPPA@user32?$AA@
  00074	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 299  : 	HookAddHook("user32", "CloseClipboard", NewCloseClipboard);

  0007c	68 00 00 00 00	 push	 OFFSET FLAT:?NewCloseClipboard@@YGHXZ ; NewCloseClipboard
  00081	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0P@GJGAPMJD@CloseClipboard?$AA@
  00086	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06KMMDPPA@user32?$AA@
  0008b	e8 00 00 00 00	 call	 ?HookAddHook@@YAXPBD0PAX@Z ; HookAddHook
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH

; 300  : 	//HookAddHook("user32", "SetClipboardViewer", NewSetClipboardViewer);
; 301  : 	//HookAddHook("user32", "ChangeClipboardChain", NewChangeClipboardChain);
; 302  : 	HookAddGetProcAddressHook();

  00093	e8 00 00 00 00	 call	 ?HookAddGetProcAddressHook@@YAXXZ ; HookAddGetProcAddressHook

; 303  : 	HookAllLoadedAndFutureModules();

  00098	e8 00 00 00 00	 call	 ?HookAllLoadedAndFutureModules@@YAXXZ ; HookAllLoadedAndFutureModules

; 304  : 	return 0;

  0009d	33 c0		 xor	 eax, eax

; 305  : }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
_ApplyHooks ENDP
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	75 09		 jne	 SHORT $L28292
  00015	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  0001c	eb 12		 jmp	 SHORT $L28293
$L28292:
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00027	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0002a	c1 f8 02	 sar	 eax, 2
  0002d	89 45 b8	 mov	 DWORD PTR tv70[ebp], eax
$L28293:
  00030	8b 45 b8	 mov	 eax, DWORD PTR tv70[ebp]

; 517  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ; std::vector<void *,std::allocator<void *> >::begin
PUBLIC	??Diterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEAAPAXXZ ; std::vector<void *,std::allocator<void *> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV012@H@Z ; std::vector<void *,std::allocator<void *> >::iterator::operator+
; Function compile flags: /Odt /ZI
;	COMDAT ??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z
_TEXT	SEGMENT
$T28296 = -76						; size = 4
$T28297 = -72						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::operator[], COMDAT
; _this$ = ecx

; 554  : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (*(begin() + _Pos));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d b8	 lea	 ecx, DWORD PTR $T28297[ebp]
  00013	51		 push	 ecx
  00014	8d 55 b4	 lea	 edx, DWORD PTR $T28296[ebp]
  00017	52		 push	 edx
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ; std::vector<void *,std::allocator<void *> >::begin
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 ??Hiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV012@H@Z ; std::vector<void *,std::allocator<void *> >::iterator::operator+
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 ??Diterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEAAPAXXZ ; std::vector<void *,std::allocator<void *> >::iterator::operator*

; 556  : 		}

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??A?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAPAXI@Z ENDP ; std::vector<void *,std::allocator<void *> >::operator[]
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::capacity
PUBLIC	?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ; std::vector<void *,std::allocator<void *> >::end
PUBLIC	?insert@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@V312@ABQAX@Z ; std::vector<void *,std::allocator<void *> >::insert
PUBLIC	?_Ufill@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAXIABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Ufill
; Function compile flags: /Odt /ZI
;	COMDAT ?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z
_TEXT	SEGMENT
$T28300 = -76						; size = 4
$T28301 = -72						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
  00014	8b f0		 mov	 esi, eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::capacity
  0001e	3b f0		 cmp	 esi, eax
  00020	73 1d		 jae	 SHORT $L27667

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

  00022	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00025	50		 push	 eax
  00026	6a 01		 push	 1
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002e	52		 push	 edx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAXIABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Ufill
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 582  : 		else

  0003d	eb 1f		 jmp	 SHORT $L27666
$L27667:

; 583  : 			insert(end(), _Val);

  0003f	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00042	50		 push	 eax
  00043	8d 4d b4	 lea	 ecx, DWORD PTR $T28300[ebp]
  00046	51		 push	 ecx
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ; std::vector<void *,std::allocator<void *> >::end
  0004f	8b 10		 mov	 edx, DWORD PTR [eax]
  00051	52		 push	 edx
  00052	8d 45 b8	 lea	 eax, DWORD PTR $T28301[ebp]
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?insert@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@V312@ABQAX@Z ; std::vector<void *,std::allocator<void *> >::insert
$L27666:

; 584  : 		}

  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
?push_back@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::push_back
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy
; Function compile flags: /Odt /ZI
;	COMDAT ?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy

; 745  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?clear@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEXXZ ENDP ; std::vector<void *,std::allocator<void *> >::clear
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	75 09		 jne	 SHORT $L28306
  00015	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  0001c	eb 12		 jmp	 SHORT $L28307
$L28306:
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00027	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  0002a	c1 f8 02	 sar	 eax, 2
  0002d	89 45 b8	 mov	 DWORD PTR tv70[ebp], eax
$L28307:
  00030	8b 45 b8	 mov	 eax, DWORD PTR tv70[ebp]

; 459  : 		}

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::capacity
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z ; std::vector<void *,std::allocator<void *> >::iterator::iterator
; Function compile flags: /Odt /ZI
;	COMDAT ?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	51		 push	 ecx
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00016	e8 00 00 00 00	 call	 ??0iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z ; std::vector<void *,std::allocator<void *> >::iterator::iterator
  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<void *,std::allocator<void *> >::begin
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00012	51		 push	 ecx
  00013	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00016	e8 00 00 00 00	 call	 ??0iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z ; std::vector<void *,std::allocator<void *> >::iterator::iterator
  0001b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?end@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<void *,std::allocator<void *> >::end
_TEXT	ENDS
PUBLIC	??Giterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<void *,std::allocator<void *> >::iterator::operator-
PUBLIC	?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Insert_n
; Function compile flags: /Odt /ZI
;	COMDAT ?insert@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@V312@ABQAX@Z
_TEXT	SEGMENT
tv73 = -84						; size = 4
$T28314 = -80						; size = 4
$T28317 = -76						; size = 4
__Off$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@V312@ABQAX@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
  00014	85 c0		 test	 eax, eax
  00016	75 09		 jne	 SHORT $L28315
  00018	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0001f	eb 18		 jmp	 SHORT $L28316
$L28315:
  00021	8d 45 b0	 lea	 eax, DWORD PTR $T28314[ebp]
  00024	50		 push	 eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ; std::vector<void *,std::allocator<void *> >::begin
  0002d	50		 push	 eax
  0002e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00031	e8 00 00 00 00	 call	 ??Giterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<void *,std::allocator<void *> >::iterator::operator-
  00036	89 45 ac	 mov	 DWORD PTR tv73[ebp], eax
$L28316:
  00039	8b 4d ac	 mov	 ecx, DWORD PTR tv73[ebp]
  0003c	89 4d f8	 mov	 DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

  0003f	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00042	50		 push	 eax
  00043	6a 01		 push	 1
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00048	51		 push	 ecx
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Insert_n

; 623  : 		return (begin() + _Off);

  00051	8b 45 f8	 mov	 eax, DWORD PTR __Off$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00058	51		 push	 ecx
  00059	8d 55 b4	 lea	 edx, DWORD PTR $T28317[ebp]
  0005c	52		 push	 edx
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?begin@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@XZ ; std::vector<void *,std::allocator<void *> >::begin
  00065	8b c8		 mov	 ecx, eax
  00067	e8 00 00 00 00	 call	 ??Hiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV012@H@Z ; std::vector<void *,std::allocator<void *> >::iterator::operator+
  0006c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
  00071	5b		 pop	 ebx
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE?AViterator@12@V312@ABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::insert
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z	; std::allocator<void *>::deallocate
PUBLIC	?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy
; Function compile flags: /Odt /ZI
;	COMDAT ?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00013	74 35		 je	 SHORT $L27699

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	51		 push	 ecx
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00022	50		 push	 eax
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00034	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00037	c1 fa 02	 sar	 edx, 2
  0003a	52		 push	 edx
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00041	51		 push	 ecx
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z ; std::allocator<void *>::deallocate
$L27699:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00061	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 798  : 		}

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAPAXIPAXV?$allocator@PAX@std@@@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@@Z ; std::_Uninitialized_fill_n<void * *,unsigned int,void *,std::allocator<void *> >
; Function compile flags: /Odt /ZI
;	COMDAT ?_Ufill@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAXIABQAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAXIABQAX@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00017	52		 push	 edx
  00018	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@PAPAXIPAXV?$allocator@PAX@std@@@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@@Z ; std::_Uninitialized_fill_n<void * *,unsigned int,void *,std::allocator<void *> >
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 879  : 		return (_Ptr + _Count);

  00024	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 880  : 		}

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAXIABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Ufill
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEABQAXXZ ; std::vector<void *,std::allocator<void *> >::const_iterator::operator*
; Function compile flags: /Odt /ZI
;	COMDAT ??Diterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEAAPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEAAPAXXZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??Dconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEABQAXXZ ; std::vector<void *,std::allocator<void *> >::const_iterator::operator*

; 221  : 			}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??Diterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEAAPAXXZ ENDP ; std::vector<void *,std::allocator<void *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV012@H@Z ; std::vector<void *,std::allocator<void *> >::iterator::operator+=
; Function compile flags: /Odt /ZI
;	COMDAT ??Hiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d f8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00017	50		 push	 eax
  00018	8d 4d f8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0001b	e8 00 00 00 00	 call	 ??Yiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV012@H@Z ; std::vector<void *,std::allocator<void *> >::iterator::operator+=
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx
  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??Hiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<void *,std::allocator<void *> >::iterator::operator+
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z ; std::_Destroy_range<void *,std::allocator<void *> >
; Function compile flags: /Odt /ZI
;	COMDAT ?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z ; std::_Destroy_range<void *,std::allocator<void *> >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 788  : 		}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
PUBLIC	??$fill@PAPAXPAX@std@@YAXPAPAX0ABQAX@Z		; std::fill<void * *,void *>
PUBLIC	??$copy_backward@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ; std::copy_backward<void * *,void * *>
PUBLIC	?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z	; std::allocator<void *>::allocate
PUBLIC	?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
PUBLIC	?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ ; std::vector<void *,std::allocator<void *> >::_Xlen
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z$0
__catchsym$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z$2
__tryblocktable$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z$5
__ehfuncinfo$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z DD 019930520H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z
	DD	2 DUP(00H)
; Function compile flags: /Odt /ZI
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z
_TEXT	SEGMENT
tv240 = -108						; size = 4
tv239 = -108						; size = 4
tv85 = -108						; size = 4
__Oldend$27766 = -40					; size = 4
__Ptr$27746 = -36					; size = 4
__Newvec$27745 = -32					; size = 4
__Capacity$ = -28					; size = 4
__Tmp$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

  00025	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d e8	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 811  : 		size_type _Capacity = capacity();

  0002d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?capacity@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::capacity
  00035	89 45 e4	 mov	 DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

  00038	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003c	75 05		 jne	 SHORT $L27739

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

  0003e	e9 c6 02 00 00	 jmp	 $L28329
$L27739:
  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
  0004b	8b f0		 mov	 esi, eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
  00055	2b c6		 sub	 eax, esi
  00057	3b 45 0c	 cmp	 eax, DWORD PTR __Count$[ebp]
  0005a	73 0d		 jae	 SHORT $L27741

; 816  : 			_Xlen();	// result too long

  0005c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ ; std::vector<void *,std::allocator<void *> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

  00064	e9 a0 02 00 00	 jmp	 $L28329
$L27741:
  00069	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
  00071	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00074	39 45 e4	 cmp	 DWORD PTR __Capacity$[ebp], eax
  00077	0f 83 66 01 00
	00		 jae	 $L27743

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0007d	8b 75 e4	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00080	d1 ee		 shr	 esi, 1
  00082	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
  0008a	2b c6		 sub	 eax, esi
  0008c	3b 45 e4	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0008f	73 09		 jae	 SHORT $L28330
  00091	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv85[ebp], 0
  00098	eb 0b		 jmp	 SHORT $L28331
$L28330:
  0009a	8b 45 e4	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0009d	d1 e8		 shr	 eax, 1
  0009f	03 45 e4	 add	 eax, DWORD PTR __Capacity$[ebp]
  000a2	89 45 94	 mov	 DWORD PTR tv85[ebp], eax
$L28331:
  000a5	8b 4d 94	 mov	 ecx, DWORD PTR tv85[ebp]
  000a8	89 4d e4	 mov	 DWORD PTR __Capacity$[ebp], ecx

; 821  : 			if (_Capacity < size() + _Count)

  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
  000b3	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000b6	39 45 e4	 cmp	 DWORD PTR __Capacity$[ebp], eax
  000b9	73 0e		 jae	 SHORT $L27744

; 822  : 				_Capacity = size() + _Count;

  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
  000c3	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  000c6	89 45 e4	 mov	 DWORD PTR __Capacity$[ebp], eax
$L27744:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

  000c9	8b 45 e4	 mov	 eax, DWORD PTR __Capacity$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z ; std::allocator<void *>::allocate
  000d5	89 45 e0	 mov	 DWORD PTR __Newvec$27745[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

  000d8	8b 45 e0	 mov	 eax, DWORD PTR __Newvec$27745[ebp]
  000db	89 45 dc	 mov	 DWORD PTR __Ptr$27746[ebp], eax

; 825  : 
; 826  : 			_TRY_BEGIN

  000de	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

  000e5	8b 45 e0	 mov	 eax, DWORD PTR __Newvec$27745[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  000ec	51		 push	 ecx
  000ed	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000f0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f3	50		 push	 eax
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
  000fc	89 45 94	 mov	 DWORD PTR tv239[ebp], eax
  000ff	8b 4d 94	 mov	 ecx, DWORD PTR tv239[ebp]
  00102	89 4d dc	 mov	 DWORD PTR __Ptr$27746[ebp], ecx

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

  00105	8d 45 e8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00108	50		 push	 eax
  00109	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0010c	51		 push	 ecx
  0010d	8b 55 dc	 mov	 edx, DWORD PTR __Ptr$27746[ebp]
  00110	52		 push	 edx
  00111	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAXIABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Ufill
  00119	89 45 94	 mov	 DWORD PTR tv240[ebp], eax
  0011c	8b 45 94	 mov	 eax, DWORD PTR tv240[ebp]
  0011f	89 45 dc	 mov	 DWORD PTR __Ptr$27746[ebp], eax

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

  00122	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$27746[ebp]
  00125	50		 push	 eax
  00126	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0012c	52		 push	 edx
  0012d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00130	50		 push	 eax
  00131	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	e8 00 00 00 00	 call	 ??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
  00139	eb 29		 jmp	 SHORT $L28333
__catch$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z$0:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

  0013b	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$27746[ebp]
  0013e	50		 push	 eax
  0013f	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$27745[ebp]
  00142	51		 push	 ecx
  00143	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

  0014b	8b 45 e4	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$27745[ebp]
  00152	51		 push	 ecx
  00153	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00156	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z ; std::allocator<void *>::deallocate

; 834  : 			_RERAISE;

  0015b	6a 00		 push	 0
  0015d	6a 00		 push	 0
  0015f	e8 00 00 00 00	 call	 __CxxThrowException@8
$L28333:

; 835  : 			_CATCH_END

  00164	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 836  : 
; 837  : 			_Count += size();

  0016b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::size
  00173	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00176	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

  00179	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00180	74 35		 je	 SHORT $L27753

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

  00182	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00185	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00188	51		 push	 ecx
  00189	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0018c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0018f	50		 push	 eax
  00190	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

  00198	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0019b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0019e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  001a1	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  001a4	c1 fa 02	 sar	 edx, 2
  001a7	52		 push	 edx
  001a8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001ab	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ae	51		 push	 ecx
  001af	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z ; std::allocator<void *>::deallocate
$L27753:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

  001b7	8b 45 e4	 mov	 eax, DWORD PTR __Capacity$[ebp]
  001ba	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$27745[ebp]
  001bd	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  001c0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001c3	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 844  : 			_Mylast = _Newvec + _Count;

  001c6	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001c9	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$27745[ebp]
  001cc	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  001cf	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001d2	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 845  : 			_Myfirst = _Newvec;

  001d5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001d8	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$27745[ebp]
  001db	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

  001de	e9 26 01 00 00	 jmp	 $L28329
$L27743:
  001e3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001e9	2b 4d 08	 sub	 ecx, DWORD PTR __Where$[ebp]
  001ec	c1 f9 02	 sar	 ecx, 2
  001ef	3b 4d 0c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  001f2	0f 83 ad 00 00
	00		 jae	 $L27756

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

  001f8	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  001fb	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  001fe	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00201	52		 push	 edx
  00202	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00205	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00208	51		 push	 ecx
  00209	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  0020c	52		 push	 edx
  0020d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00210	e8 00 00 00 00	 call	 ??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>

; 851  : 
; 852  : 			_TRY_BEGIN

  00215	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 2

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

  0021c	8d 45 e8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0021f	50		 push	 eax
  00220	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00223	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00226	2b 55 08	 sub	 edx, DWORD PTR __Where$[ebp]
  00229	c1 fa 02	 sar	 edx, 2
  0022c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0022f	2b c2		 sub	 eax, edx
  00231	50		 push	 eax
  00232	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00235	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00238	52		 push	 edx
  00239	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0023c	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAXIABQAX@Z ; std::vector<void *,std::allocator<void *> >::_Ufill
  00241	eb 28		 jmp	 SHORT $L28335
__catch$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z$2:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

  00243	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00246	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00249	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0024c	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0024f	50		 push	 eax
  00250	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00253	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  00256	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00259	50		 push	 eax
  0025a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0025d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXPAPAX0@Z ; std::vector<void *,std::allocator<void *> >::_Destroy

; 857  : 			_RERAISE;

  00262	6a 00		 push	 0
  00264	6a 00		 push	 0
  00266	e8 00 00 00 00	 call	 __CxxThrowException@8
$L28335:

; 858  : 			_CATCH_END

  0026b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 859  : 
; 860  : 			_Mylast += _Count;

  00272	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00275	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00278	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0027b	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0027e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00281	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

  00284	8d 45 e8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00287	50		 push	 eax
  00288	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0028b	c1 e1 02	 shl	 ecx, 2
  0028e	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00291	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00294	2b c1		 sub	 eax, ecx
  00296	50		 push	 eax
  00297	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  0029a	51		 push	 ecx
  0029b	e8 00 00 00 00	 call	 ??$fill@PAPAXPAX@std@@YAXPAPAX0ABQAX@Z ; std::fill<void * *,void *>
  002a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 863  : 			}
; 864  : 		else

  002a3	eb 64		 jmp	 SHORT $L28329
$L27756:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

  002a5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002a8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002ab	89 4d d8	 mov	 DWORD PTR __Oldend$27766[ebp], ecx

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

  002ae	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  002b1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002b4	51		 push	 ecx
  002b5	8b 55 d8	 mov	 edx, DWORD PTR __Oldend$27766[ebp]
  002b8	52		 push	 edx
  002b9	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  002bc	c1 e0 02	 shl	 eax, 2
  002bf	8b 4d d8	 mov	 ecx, DWORD PTR __Oldend$27766[ebp]
  002c2	2b c8		 sub	 ecx, eax
  002c4	51		 push	 ecx
  002c5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002c8	e8 00 00 00 00	 call	 ??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
  002cd	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002d0	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

  002d3	8b 45 d8	 mov	 eax, DWORD PTR __Oldend$27766[ebp]
  002d6	50		 push	 eax
  002d7	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002da	c1 e1 02	 shl	 ecx, 2
  002dd	8b 55 d8	 mov	 edx, DWORD PTR __Oldend$27766[ebp]
  002e0	2b d1		 sub	 edx, ecx
  002e2	52		 push	 edx
  002e3	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 ??$copy_backward@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ; std::copy_backward<void * *,void * *>
  002ec	83 c4 0c	 add	 esp, 12			; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

  002ef	8d 45 e8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  002f2	50		 push	 eax
  002f3	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002f6	8b 55 08	 mov	 edx, DWORD PTR __Where$[ebp]
  002f9	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  002fc	50		 push	 eax
  002fd	8b 4d 08	 mov	 ecx, DWORD PTR __Where$[ebp]
  00300	51		 push	 ecx
  00301	e8 00 00 00 00	 call	 ??$fill@PAPAXPAX@std@@YAXPAPAX0ABQAX@Z ; std::fill<void * *,void *>
  00306	83 c4 0c	 add	 esp, 12			; 0000000cH
$L28329:

; 873  : 			}
; 874  : 		}

  00309	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0030c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00313	5f		 pop	 edi
  00314	5e		 pop	 esi
  00315	5b		 pop	 ebx
  00316	8b e5		 mov	 esp, ebp
  00318	5d		 pop	 ebp
  00319	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXViterator@12@IABQAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Insert_n
PUBLIC	?max_size@?$allocator@PAX@std@@QBEIXZ		; std::allocator<void *>::max_size
; Function compile flags: /Odt /ZI
;	COMDAT ?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$allocator@PAX@std@@QBEIXZ ; std::allocator<void *>::max_size

; 522  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ENDP ; std::vector<void *,std::allocator<void *> >::max_size
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt /ZI
_DATA	ENDS
;	COMDAT ?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T28352 = -148						; size = 40
$T28353 = -108						; size = 28
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

  00024	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00029	8d 4d 94	 lea	 ecx, DWORD PTR $T28353[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	8d 45 94	 lea	 eax, DWORD PTR $T28353[ebp]
  0003b	50		 push	 eax
  0003c	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T28352[ebp]
  00042	e8 00 00 00 00	 call	 ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
  00047	68 00 00 00 00	 push	 OFFSET FLAT:__TI3?AVlength_error@std@@
  0004c	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T28352[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 __CxxThrowException@8
$L28351:

; 885  : 		}

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ$0:
  00000	8d 4d 94	 lea	 ecx, DWORD PTR $T28353[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ ENDP ; std::vector<void *,std::allocator<void *> >::_Xlen
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z PROC NEAR	; std::allocator<void *>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 133  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@PAX@std@@QAEXPAPAXI@Z ENDP	; std::allocator<void *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z		; std::_Allocate<void *>
; Function compile flags: /Odt /ZI
;	COMDAT ?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z PROC NEAR	; std::allocator<void *>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z ; std::_Allocate<void *>
  00017	83 c4 08	 add	 esp, 8

; 138  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z ENDP		; std::allocator<void *>::allocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z ; std::vector<void *,std::allocator<void *> >::const_iterator::const_iterator
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0const_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z ; std::vector<void *,std::allocator<void *> >::const_iterator::const_iterator

; 216  : 			}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::iterator::iterator
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	89 01		 mov	 DWORD PTR [ecx], eax

; 257  : 			return (*this);

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 258  : 			}

  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi
  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??Yiterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<void *,std::allocator<void *> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABV012@@Z ; std::vector<void *,std::allocator<void *> >::const_iterator::operator-
; Function compile flags: /Odt /ZI
;	COMDAT ??Giterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
$T28371 = -72						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d b8	 mov	 DWORD PTR $T28371[ebp], ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00017	52		 push	 edx
  00018	8d 4d b8	 lea	 ecx, DWORD PTR $T28371[ebp]
  0001b	e8 00 00 00 00	 call	 ??Gconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABV012@@Z ; std::vector<void *,std::allocator<void *> >::const_iterator::operator-

; 280  : 			}

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??Giterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<void *,std::allocator<void *> >::iterator::operator-
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEABQAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEABQAXXZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 			}

  00011	5f		 pop	 edi
  00012	5e		 pop	 esi
  00013	5b		 pop	 ebx
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??Dconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEABQAXXZ ENDP ; std::vector<void *,std::allocator<void *> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV01@@Z
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str

; 28   : 		}

  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 44	 sub	 esp, 68			; 00000044H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00021	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00024	50		 push	 eax
  00025	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??0exception@@QAE@ABV0@@Z ; exception::exception
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  0003d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00040	83 c0 0c	 add	 eax, 12			; 0000000cH
  00043	50		 push	 eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt /ZI
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $L25391
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$L25391:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /ZI
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1logic_error@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 44	 sub	 esp, 68			; 00000044H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00021	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00037	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??1exception@@UAE@XZ	; exception::~exception
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??1logic_error@std@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$??1logic_error@std@@UAE@XZ
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 360  : 		{	// construct from [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 361  : 		_Tidy();

  0001c	6a 00		 push	 0
  0001e	6a 00		 push	 0
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 362  : 		assign(_Ptr);

  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 363  : 		}

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAX@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@PAX@std@@QBEIXZ PROC NEAR		; std::allocator<void *>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $L28406
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $L28407
$L28406:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L28407:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@PAX@std@@QBEIXZ ENDP		; std::allocator<void *>::max_size
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx

; 76   : 			}

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	5f		 pop	 edi
  00018	5e		 pop	 esi
  00019	5b		 pop	 ebx
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??0const_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@PAPAX@Z ENDP ; std::vector<void *,std::allocator<void *> >::const_iterator::const_iterator
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	2b 01		 sub	 eax, DWORD PTR [ecx]
  00016	c1 f8 02	 sar	 eax, 2

; 144  : 			}

  00019	5f		 pop	 edi
  0001a	5e		 pop	 esi
  0001b	5b		 pop	 ebx
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??Gconst_iterator@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<void *,std::allocator<void *> >::const_iterator::operator-
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length
  00015	83 c4 04	 add	 esp, 4
  00018	50		 push	 eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 623  : 		}

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 351  : 		{	// find length of null-terminated string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 352  : 		return (::strlen(_First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4

; 353  : 		}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 609  : 		if (_Inside(_Ptr))

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
  00018	0f b6 c8	 movzx	 ecx, al
  0001b	85 c9		 test	 ecx, ecx
  0001d	74 20		 je	 SHORT $L27838

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

  0001f	8b 45 0c	 mov	 eax, DWORD PTR __Num$[ebp]
  00022	50		 push	 eax
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002e	2b c8		 sub	 ecx, eax
  00030	51		 push	 ecx
  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	52		 push	 edx
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0003d	eb 3d		 jmp	 SHORT $L27837
$L27838:

; 611  : 
; 612  : 		if (_Grow(_Num))

  0003f	6a 00		 push	 0
  00041	8b 45 0c	 mov	 eax, DWORD PTR __Num$[ebp]
  00044	50		 push	 eax
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  0004d	0f b6 c8	 movzx	 ecx, al
  00050	85 c9		 test	 ecx, ecx
  00052	74 25		 je	 SHORT $L27839

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

  00054	8b 45 0c	 mov	 eax, DWORD PTR __Num$[ebp]
  00057	50		 push	 eax
  00058	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 615  : 			_Eos(_Num);

  0006d	8b 45 0c	 mov	 eax, DWORD PTR __Num$[ebp]
  00070	50		 push	 eax
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L27839:

; 616  : 			}
; 617  : 		return (*this);

  00079	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$L27837:

; 618  : 		}

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 357  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _memcpy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 359  : 		}

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /ZI
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 44	 sub	 esp, 68			; 00000044H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??0exception@@QAE@XZ	; exception::exception
  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
  00039	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00043	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 20   : 		}

  00048	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@@UAE@XZ	; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odt /ZI
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ ; std::logic_error::~logic_error
  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00014	39 45 08	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00017	72 13		 jb	 SHORT $L27843
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	03 41 14	 add	 eax, DWORD PTR [ecx+20]
  00027	3b 45 08	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  0002a	77 04		 ja	 SHORT $L27842
$L27843:

; 1496 : 			return (false);	// don't ask

  0002c	32 c0		 xor	 al, al
  0002e	eb 02		 jmp	 SHORT $L27841
$L27842:

; 1497 : 		else
; 1498 : 			return (true);

  00030	b0 01		 mov	 al, 1
$L27841:

; 1499 : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??1length_error@std@@UAE@XZ ; std::length_error::~length_error
  00014	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $L25457
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00025	83 c4 04	 add	 esp, 4
$L25457:
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void>
PUBLIC	??$_Uninit_fill_n@PAXIPAX@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<void *,unsigned int,void *>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAPAXIPAXV?$allocator@PAX@std@@@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT
$T28444 = -65						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAPAXIPAXV?$allocator@PAX@std@@@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<void * *,unsigned int,void *,std::allocator<void *> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T28444[ebp], al
  0001c	8a 55 bf	 mov	 dl, BYTE PTR $T28444[ebp]
  0001f	52		 push	 edx
  00020	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PAXIPAX@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<void *,unsigned int,void *>
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 258  : 	}

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$_Uninitialized_fill_n@PAPAXIPAXV?$allocator@PAX@std@@@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@@Z ENDP ; std::_Uninitialized_fill_n<void * *,unsigned int,void *,std::allocator<void *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<void *,std::allocator<void *> >
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT
$T28447 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z PROC NEAR ; std::_Destroy_range<void *,std::allocator<void *> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T28447[ebp], al
  0001c	8a 55 bf	 mov	 dl, BYTE PTR $T28447[ebp]
  0001f	52		 push	 edx
  00020	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<void *,std::allocator<void *> >
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 218  : 	}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@@Z ENDP ; std::_Destroy_range<void *,std::allocator<void *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@@Z ; std::_Uninitialized_copy<void * *,void * *,std::allocator<void *> >
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00017	52		 push	 edx
  00018	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@@Z ; std::_Uninitialized_copy<void * *,void * *,std::allocator<void *> >
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 805  : 		}

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAPAX@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEPAPAXPAPAX00@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Ucopy<void * *>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAPAXPAX@std@@YAXPAPAX0ABQAX@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAXPAX@std@@YAXPAPAX0ABQAX@Z PROC NEAR	; std::fill<void * *,void *>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1135 : 	for (; _First != _Last; ++_First)

  00009	eb 09		 jmp	 SHORT $L27995
$L27996:
  0000b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000e	83 c0 04	 add	 eax, 4
  00011	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$L27995:
  00014	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00017	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001a	74 0c		 je	 SHORT $L27994

; 1136 : 		*_First = _Val;

  0001c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001f	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	89 10		 mov	 DWORD PTR [eax], edx
  00026	eb e3		 jmp	 SHORT $L27996
$L27994:

; 1137 : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$fill@PAPAXPAX@std@@YAXPAPAX0ABQAX@Z ENDP		; std::fill<void * *,void *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<void * *,void * *>
; Function compile flags: /Odt /ZI
;	COMDAT ??$copy_backward@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z
_TEXT	SEGMENT
$T28454 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z PROC NEAR ; std::copy_backward<void * *,void * *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T28454[ebp], al
  0001c	8a 55 bf	 mov	 dl, BYTE PTR $T28454[ebp]
  0001f	52		 push	 edx
  00020	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??$_Copy_backward_opt@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<void * *,void * *>
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 1070 : 	}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$copy_backward@PAPAXPAPAX@std@@YAPAPAXPAPAX00@Z ENDP	; std::copy_backward<void * *,void * *>
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z PROC NEAR		; std::_Allocate<void *>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	c1 e0 02	 shl	 eax, 2
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4

; 35   : 	}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Allocate@PAX@std@@YAPAPAXIPAPAX@Z ENDP		; std::_Allocate<void *>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z PROC NEAR ; std::_Ptr_cat<void>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

  00009	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 221  : 	}

  0000c	5f		 pop	 edi
  0000d	5e		 pop	 esi
  0000e	5b		 pop	 ebx
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ENDP ; std::_Ptr_cat<void>
_TEXT	ENDS
PUBLIC	??$fill_n@PAPAXIPAX@std@@YAXPAPAXIABQAX@Z	; std::fill_n<void * *,unsigned int,void *>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_fill_n@PAXIPAX@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAXIPAX@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<void *,unsigned int,void *>, COMDAT

; 236  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 237  : 	fill_n(_First, _Count, _Val);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ??$fill_n@PAPAXIPAX@std@@YAXPAPAXIABQAX@Z ; std::fill_n<void * *,unsigned int,void *>
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 238  : 	}

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Uninit_fill_n@PAXIPAX@std@@YAXPAPAXIABQAXAAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<void *,unsigned int,void *>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<void *,std::allocator<void *> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), scalar type (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 234  : 	}

  00009	5f		 pop	 edi
  0000a	5e		 pop	 esi
  0000b	5b		 pop	 ebx
  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$_Destroy_range@PAXV?$allocator@PAX@std@@@std@@YAXPAPAX0AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<void *,std::allocator<void *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<void *,void *>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@@Z
_TEXT	SEGMENT
$T28465 = -65						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@@Z PROC NEAR ; std::_Uninitialized_copy<void * *,void * *,std::allocator<void *> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Ptr_cat@X@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAX0@Z ; std::_Ptr_cat<void>
  00016	83 c4 08	 add	 esp, 8
  00019	88 45 bf	 mov	 BYTE PTR $T28465[ebp], al
  0001c	8a 55 bf	 mov	 dl, BYTE PTR $T28465[ebp]
  0001f	52		 push	 edx
  00020	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<void *,void *>
  00035	83 c4 14	 add	 esp, 20			; 00000014H

; 129  : 	}

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$_Uninitialized_copy@PAPAXPAPAXV?$allocator@PAX@std@@@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@@Z ENDP ; std::_Uninitialized_copy<void * *,void * *,std::allocator<void *> >
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<void * *,void * *>, COMDAT

; 1058 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Off$[ebp], eax

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Off$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR __Off$[ebp]
  00023	c1 e2 02	 shl	 edx, 2
  00026	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00029	2b c2		 sub	 eax, edx
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _memmove
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1062 : 	}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??$_Copy_backward_opt@PAPAXPAPAX@std@@YAPAPAXPAPAX00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<void * *,void * *>
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAXIPAX@std@@YAXPAPAXIABQAX@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAPAXIPAX@std@@YAXPAPAXIABQAX@Z PROC NEAR	; std::fill_n<void * *,unsigned int,void *>, COMDAT

; 1159 : 	{	// copy _Val _Count times through [_First, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

  00009	eb 12		 jmp	 SHORT $L28076
$L28077:
  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000e	83 e8 01	 sub	 eax, 1
  00011	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	83 c1 04	 add	 ecx, 4
  0001a	89 4d 08	 mov	 DWORD PTR __First$[ebp], ecx
$L28076:
  0001d	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00021	76 0c		 jbe	 SHORT $L28075

; 1161 : 		*_First = _Val;

  00023	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00026	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 10		 mov	 DWORD PTR [eax], edx
  0002d	eb dc		 jmp	 SHORT $L28077
$L28075:

; 1162 : 	}

  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$fill_n@PAPAXIPAX@std@@YAXPAPAXIABQAX@Z ENDP		; std::fill_n<void * *,unsigned int,void *>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<void *,void *>, COMDAT

; 105  : 	{	// copy [_First, _Last) to raw _Dest, (const) scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 106  : 	size_t _Count = (size_t)(_Last - _First);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
  00012	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00015	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00018	c1 e0 02	 shl	 eax, 2
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00023	52		 push	 edx
  00024	e8 00 00 00 00	 call	 _memmove
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002f	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 109  : 	}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_copy@PAXPAX@std@@YAPAPAXPAPAX00AAV?$allocator@PAX@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<void *,void *>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odt /ZI
CONST	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 324  : 		_Tidy();

  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 325  : 		assign(_Right, 0, npos);

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00037	51		 push	 ecx
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

  0000c	6a 00		 push	 0
  0000e	6a 01		 push	 1
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 458  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /ZI
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1093 : 		{	// return pointer to null-terminated nonmutable array

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1094 : 		return (_Myptr());

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1095 : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Odt /ZI
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Right.size() < _Roff)

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00017	73 08		 jae	 SHORT $L26140

; 592  : 			_String_base::_Xran();	// _Roff off end

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L26140:

; 593  : 		size_type _Num = _Right.size() - _Roff;

  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00029	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  0002c	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 594  : 		if (_Count < _Num)

  0002f	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00032	3b 45 f8	 cmp	 eax, DWORD PTR __Num$[ebp]
  00035	73 06		 jae	 SHORT $L26142

; 595  : 			_Num = _Count;	// trim _Num to size

  00037	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax
$L26142:

; 596  : 
; 597  : 		if (this == &_Right)

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	3b 45 08	 cmp	 eax, DWORD PTR __Right$[ebp]
  00043	75 25		 jne	 SHORT $L26143

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
  0004a	50		 push	 eax
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  0004e	03 4d f8	 add	 ecx, DWORD PTR __Num$[ebp]
  00051	51		 push	 ecx
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  0005a	8b 55 0c	 mov	 edx, DWORD PTR __Roff$[ebp]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 599  : 		else if (_Grow(_Num))

  00068	eb 42		 jmp	 SHORT $L26261
$L26143:
  0006a	6a 00		 push	 0
  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
  00078	0f b6 c8	 movzx	 ecx, al
  0007b	85 c9		 test	 ecx, ecx
  0007d	74 2d		 je	 SHORT $L26261

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

  0007f	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  00082	50		 push	 eax
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0008b	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  0008e	50		 push	 eax
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 602  : 			_Eos(_Num);

  000a0	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  000a3	50		 push	 eax
  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L26261:

; 603  : 			}
; 604  : 		return (*this);

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 605  : 		}

  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Odt /ZI
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$26268 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

  0000c	0f b6 45 08	 movzx	 eax, BYTE PTR __Built$[ebp]
  00010	85 c0		 test	 eax, eax
  00012	75 02		 jne	 SHORT $L26265

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

  00014	eb 45		 jmp	 SHORT $L26266
$L26265:
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  0001d	72 3c		 jb	 SHORT $L26266

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00025	89 4d f8	 mov	 DWORD PTR __Ptr$26268[ebp], ecx

; 1515 : 			if (0 < _Newsize)

  00028	83 7d 0c 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0002c	76 17		 jbe	 SHORT $L26269

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00031	50		 push	 eax
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$26268[ebp]
  00035	51		 push	 ecx
  00036	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00039	83 c2 04	 add	 edx, 4
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$L26269:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0004b	83 c1 01	 add	 ecx, 1
  0004e	51		 push	 ecx
  0004f	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$26268[ebp]
  00052	52		 push	 edx
  00053	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$L26266:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 1520 : 		_Eos(_Newsize);

  00065	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1521 : 		}

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 08 00	 ret	 8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1536 : 		{	// determine current pointer to buffer for nonmutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00013	72 0b		 jb	 SHORT $L28485
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv70[ebp], edx
  0001e	eb 09		 jmp	 SHORT $L28486
$L28485:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 b8	 mov	 DWORD PTR tv70[ebp], eax
$L28486:
  00029	8b 45 b8	 mov	 eax, DWORD PTR tv70[ebp]

; 1538 : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@ABV01@@Z ; std::allocator<char>::allocator<char>

; 35   : 		}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$26281 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00012	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00015	73 08		 jae	 SHORT $L26278

; 794  : 			_String_base::_Xran();	// _Off off end

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Xran@_String_base@std@@QBEXXZ ; std::_String_base::_Xran
$L26278:

; 795  : 		if (_Mysize - _Off < _Count)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00025	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00028	3b 4d 0c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0002b	73 0c		 jae	 SHORT $L26279

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00033	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00036	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
$L26279:

; 797  : 		if (0 < _Count)

  00039	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003d	76 48		 jbe	 SHORT $L26280

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00045	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00048	2b 4d 0c	 sub	 ecx, DWORD PTR __Count$[ebp]
  0004b	51		 push	 ecx
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00054	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00057	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00063	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00075	2b 4d 0c	 sub	 ecx, DWORD PTR __Count$[ebp]
  00078	89 4d f8	 mov	 DWORD PTR __Newsize$26281[ebp], ecx

; 802  : 			_Eos(_Newsize);

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$26281[ebp]
  0007e	50		 push	 eax
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L26280:

; 803  : 			}
; 804  : 		return (*this);

  00087	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 805  : 		}

  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 369  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

  00009	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _memmove
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 371  : 		}

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 1110 : 		}

  00012	5f		 pop	 edi
  00013	5e		 pop	 esi
  00014	5b		 pop	 ebx
  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odt /ZI
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T28499 = -69						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

  0000c	c6 45 bb 00	 mov	 BYTE PTR $T28499[ebp], 0
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00016	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00019	8d 55 bb	 lea	 edx, DWORD PTR $T28499[ebp]
  0001c	52		 push	 edx
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  00025	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
  0002e	83 c4 08	 add	 esp, 8

; 1476 : 		}

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 330  : 		{	// assign an element

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 331  : 		_Left = _Right;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 10		 mov	 BYTE PTR [eax], dl

; 332  : 		}

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -72						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00014	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00017	73 08		 jae	 SHORT $L26289

; 1482 : 			_String_base::_Xlen();	// result too long

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Xlen@_String_base@std@@QBEXXZ ; std::_String_base::_Xlen
$L26289:

; 1483 : 		if (_Myres < _Newsize)

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00027	3b 4d 08	 cmp	 ecx, DWORD PTR __Newsize$[ebp]
  0002a	73 15		 jae	 SHORT $L26290

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00036	52		 push	 edx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

  0003f	eb 4a		 jmp	 SHORT $L26291
$L26290:
  00041	0f b6 45 0c	 movzx	 eax, BYTE PTR __Trim$[ebp]
  00045	85 c0		 test	 eax, eax
  00047	74 32		 je	 SHORT $L26292
  00049	83 7d 08 10	 cmp	 DWORD PTR __Newsize$[ebp], 16 ; 00000010H
  0004d	73 2c		 jae	 SHORT $L26292

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00055	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00058	73 08		 jae	 SHORT $L28504
  0005a	8b 55 08	 mov	 edx, DWORD PTR __Newsize$[ebp]
  0005d	89 55 b8	 mov	 DWORD PTR tv81[ebp], edx
  00060	eb 09		 jmp	 SHORT $L28505
$L28504:
  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00068	89 4d b8	 mov	 DWORD PTR tv81[ebp], ecx
$L28505:
  0006b	8b 55 b8	 mov	 edx, DWORD PTR tv81[ebp]
  0006e	52		 push	 edx
  0006f	6a 01		 push	 1
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

  00079	eb 10		 jmp	 SHORT $L26291
$L26292:
  0007b	83 7d 08 00	 cmp	 DWORD PTR __Newsize$[ebp], 0
  0007f	75 0a		 jne	 SHORT $L26291

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

  00081	6a 00		 push	 0
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L26291:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

  0008b	33 c0		 xor	 eax, eax
  0008d	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00090	1b c0		 sbb	 eax, eax
  00092	f7 d8		 neg	 eax

; 1491 : 		}

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5b		 pop	 ebx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv70 = -72						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00013	72 0b		 jb	 SHORT $L28508
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001b	89 55 b8	 mov	 DWORD PTR tv70[ebp], edx
  0001e	eb 09		 jmp	 SHORT $L28509
$L28508:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 b8	 mov	 DWORD PTR tv70[ebp], eax
$L28509:
  00029	8b 45 b8	 mov	 eax, DWORD PTR tv70[ebp]

; 1533 : 		}

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4

; 133  : 		}

  00018	5f		 pop	 edi
  00019	5e		 pop	 esi
  0001a	5b		 pop	 ebx
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -76						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size
  00014	89 45 f8	 mov	 DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00017	83 7d f8 01	 cmp	 DWORD PTR __Num$[ebp], 1
  0001b	77 09		 ja	 SHORT $L28514
  0001d	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00024	eb 09		 jmp	 SHORT $L28515
$L28514:
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Num$[ebp]
  00029	83 e8 01	 sub	 eax, 1
  0002c	89 45 b4	 mov	 DWORD PTR tv68[ebp], eax
$L28515:
  0002f	8b 45 b4	 mov	 eax, DWORD PTR tv68[ebp]

; 1116 : 		}

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$5
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z DD 019930520H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	DD	2 DUP(00H)
; Function compile flags: /Odt /ZI
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -96						; size = 4
tv144 = -96						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	51		 push	 ecx
  00019	83 ec 50	 sub	 esp, 80			; 00000050H
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00022	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

  00025	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00028	83 c8 0f	 or	 eax, 15			; 0000000fH
  0002b	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

  0002e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00036	3b 45 e8	 cmp	 eax, DWORD PTR __Newres$[ebp]
  00039	73 08		 jae	 SHORT $L26305

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

  0003b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

  00041	eb 43		 jmp	 SHORT $L26306
$L26305:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

  00043	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00049	d1 e9		 shr	 ecx, 1
  0004b	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  0004e	33 d2		 xor	 edx, edx
  00050	be 03 00 00 00	 mov	 esi, 3
  00055	f7 f6		 div	 esi
  00057	3b c1		 cmp	 eax, ecx
  00059	73 2b		 jae	 SHORT $L26306
  0005b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 70 18	 mov	 esi, DWORD PTR [eax+24]
  00061	d1 ee		 shr	 esi, 1
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0006b	2b c6		 sub	 eax, esi
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	39 41 18	 cmp	 DWORD PTR [ecx+24], eax
  00073	77 11		 ja	 SHORT $L26306

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0007b	d1 e9		 shr	 ecx, 1
  0007d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00080	03 4a 18	 add	 ecx, DWORD PTR [edx+24]
  00083	89 4d e8	 mov	 DWORD PTR __Newres$[ebp], ecx
$L26306:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

  00086	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  0008d	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  00090	83 c0 01	 add	 eax, 1
  00093	50		 push	 eax
  00094	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  0009c	89 45 a0	 mov	 DWORD PTR tv144[ebp], eax
  0009f	8b 4d a0	 mov	 ecx, DWORD PTR tv144[ebp]
  000a2	89 4d e4	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000a5	eb 4b		 jmp	 SHORT $L28518
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$0:

; 1455 : 		_CATCH_ALL

  000a7	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  000aa	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ad	89 45 e8	 mov	 DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN

  000b0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

  000b4	8b 45 e8	 mov	 eax, DWORD PTR __Newres$[ebp]
  000b7	83 c0 01	 add	 eax, 1
  000ba	50		 push	 eax
  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  000c3	89 45 a0	 mov	 DWORD PTR tv145[ebp], eax
  000c6	8b 4d a0	 mov	 ecx, DWORD PTR tv145[ebp]
  000c9	89 4d e4	 mov	 DWORD PTR __Ptr$[ebp], ecx
  000cc	eb 15		 jmp	 SHORT $L28520
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$1:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

  000ce	6a 00		 push	 0
  000d0	6a 01		 push	 1
  000d2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1461 : 			_RERAISE;

  000da	6a 00		 push	 0
  000dc	6a 00		 push	 0
  000de	e8 00 00 00 00	 call	 __CxxThrowException@8
$L28520:

; 1462 : 			_CATCH_END

  000e3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

  000ea	b8 00 00 00 00	 mov	 eax, $L28523
  000ef	c3		 ret	 0
$L28523:
  000f0	eb 07		 jmp	 SHORT __tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$3
$L28518:
  000f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z$3:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

  000f9	83 7d 0c 00	 cmp	 DWORD PTR __Oldlen$[ebp], 0
  000fd	76 19		 jbe	 SHORT $L26311

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

  000ff	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00102	50		 push	 eax
  00103	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	e8 00 00 00 00	 call	 ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
  0010b	50		 push	 eax
  0010c	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0010f	51		 push	 ecx
  00110	e8 00 00 00 00	 call	 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
$L26311:

; 1467 : 		_Tidy(true);

  00118	6a 00		 push	 0
  0011a	6a 01		 push	 1
  0011c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

  00124	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00127	8b 4d e4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0012a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

  0012d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 4d e8	 mov	 ecx, DWORD PTR __Newres$[ebp]
  00133	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 1470 : 		_Eos(_Oldlen);

  00136	8b 45 0c	 mov	 eax, DWORD PTR __Oldlen$[ebp]
  00139	50		 push	 eax
  0013a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L28517:

; 1471 : 		}

  00142	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00145	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
  00005	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

  0000c	6a 00		 push	 0
  0000e	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>
  00017	83 c4 08	 add	 esp, 8

; 138  : 		}

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -76						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

  0000c	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR __Count$[ebp], -1

; 158  : 		return (0 < _Count ? _Count : 1);

  00013	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00017	76 08		 jbe	 SHORT $L28537
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 b4	 mov	 DWORD PTR tv65[ebp], eax
  0001f	eb 07		 jmp	 SHORT $L28538
$L28537:
  00021	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
$L28538:
  00028	8b 45 b4	 mov	 eax, DWORD PTR tv65[ebp]

; 159  : 		}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00012	83 c4 04	 add	 esp, 4

; 35   : 	}

  00015	5f		 pop	 edi
  00016	5e		 pop	 esi
  00017	5b		 pop	 ebx
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
EXTRN	?makeClient@@YAPAVRPCClient@@XZ:NEAR		; makeClient
CRT$XCU	SEGMENT
_$S2	DD	FLAT:_$E1
; Function compile flags: /Odt /ZI
; File c:\documents and settings\marcstgr\my documents\visual studio projects\beta\src\pethooks\pethooks.cpp
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 17   : RPCClient* client = makeClient();

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	e8 00 00 00 00	 call	 ?makeClient@@YAPAVRPCClient@@XZ ; makeClient
  0000e	a3 00 00 00 00	 mov	 DWORD PTR ?client@@3PAVRPCClient@@A, eax ; client
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
EXTRN	_atexit:NEAR
CRT$XCU	SEGMENT
_$S5	DD	FLAT:_$E3
; Function compile flags: /Odt /ZI
CRT$XCU	ENDS
;	COMDAT _$E3
text$yc	SEGMENT
_$E3	PROC NEAR					; COMDAT

; 223  : std::vector<HGLOBAL> open_handles;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?open_handles@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  0000e	e8 00 00 00 00	 call	 ??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
  00013	68 00 00 00 00	 push	 OFFSET FLAT:_$E4
  00018	e8 00 00 00 00	 call	 _atexit
  0001d	83 c4 04	 add	 esp, 4
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_$E3	ENDP
text$yc	ENDS
PUBLIC	??0?$_Vector_val@PAXV?$allocator@PAX@std@@@std@@IAE@V?$allocator@PAX@1@@Z ; std::_Vector_val<void *,std::allocator<void *> >::_Vector_val<void *,std::allocator<void *> >
PUBLIC	??0?$allocator@PAX@std@@QAE@XZ			; std::allocator<void *>::allocator<void *>
PUBLIC	?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z ; std::vector<void *,std::allocator<void *> >::_Buy
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	51		 push	 ecx
  0000d	8b cc		 mov	 ecx, esp
  0000f	e8 00 00 00 00	 call	 ??0?$allocator@PAX@std@@QAE@XZ ; std::allocator<void *>::allocator<void *>
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$_Vector_val@PAXV?$allocator@PAX@std@@@std@@IAE@V?$allocator@PAX@1@@Z ; std::_Vector_val<void *,std::allocator<void *> >::_Vector_val<void *,std::allocator<void *> >

; 300  : 		_Buy(0);

  0001c	6a 00		 push	 0
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z ; std::vector<void *,std::allocator<void *> >::_Buy

; 301  : 		}

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??0?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ENDP	; std::vector<void *,std::allocator<void *> >::vector<void *,std::allocator<void *> >
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<void *,std::allocator<void *> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

  0002a	83 7d 08 00	 cmp	 DWORD PTR __Capacity$[ebp], 0
  0002e	75 04		 jne	 SHORT $L27693

; 773  : 			return (false);

  00030	32 c0		 xor	 al, al
  00032	eb 49		 jmp	 SHORT $L27692
$L27693:

; 774  : 		else if (max_size() < _Capacity)

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?max_size@?$vector@PAXV?$allocator@PAX@std@@@std@@QBEIXZ ; std::vector<void *,std::allocator<void *> >::max_size
  0003c	3b 45 08	 cmp	 eax, DWORD PTR __Capacity$[ebp]
  0003f	73 0a		 jae	 SHORT $L27695

; 775  : 			_Xlen();	// result too long

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?_Xlen@?$vector@PAXV?$allocator@PAX@std@@@std@@IBEXXZ ; std::vector<void *,std::allocator<void *> >::_Xlen

; 776  : 		else

  00049	eb 30		 jmp	 SHORT $L27694
$L27695:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

  0004b	8b 45 08	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAX@std@@QAEPAPAXI@Z ; std::allocator<void *>::allocate
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00066	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 780  : 			_Myend = _Myfirst + _Capacity;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006f	8b 55 08	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00072	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00075	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$L27694:

; 781  : 			}
; 782  : 		return (true);

  0007b	b0 01		 mov	 al, 1
$L27692:

; 783  : 		}

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?_Buy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAE_NI@Z ENDP ; std::vector<void *,std::allocator<void *> >::_Buy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAX@std@@QAE@ABV01@@Z		; std::allocator<void *>::allocator<void *>
; Function compile flags: /Odt /ZI
;	COMDAT ??0?$_Vector_val@PAXV?$allocator@PAX@std@@@std@@IAE@V?$allocator@PAX@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@PAXV?$allocator@PAX@std@@@std@@IAE@V?$allocator@PAX@1@@Z PROC NEAR ; std::_Vector_val<void *,std::allocator<void *> >::_Vector_val<void *,std::allocator<void *> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000c	8d 45 08	 lea	 eax, DWORD PTR __Al$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$allocator@PAX@std@@QAE@ABV01@@Z ; std::allocator<void *>::allocator<void *>

; 22   : 		}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0?$_Vector_val@PAXV?$allocator@PAX@std@@@std@@IAE@V?$allocator@PAX@1@@Z ENDP ; std::_Vector_val<void *,std::allocator<void *> >::_Vector_val<void *,std::allocator<void *> >
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAX@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAX@std@@QAE@XZ PROC NEAR		; std::allocator<void *>::allocator<void *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$allocator@PAX@std@@QAE@XZ ENDP			; std::allocator<void *>::allocator<void *>
; Function compile flags: /Odt /ZI
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAX@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAX@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<void *>::allocator<void *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	5f		 pop	 edi
  00010	5e		 pop	 esi
  00011	5b		 pop	 ebx
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0?$allocator@PAX@std@@QAE@ABV01@@Z ENDP		; std::allocator<void *>::allocator<void *>
_TEXT	ENDS
PUBLIC	??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
; Function compile flags: /Odt /ZI
;	COMDAT _$E4
text$yd	SEGMENT
_$E4	PROC NEAR					; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?open_handles@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A
  0000e	e8 00 00 00 00	 call	 ??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_$E4	ENDP
; Function compile flags: /Odt /ZI
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
text$yd	ENDS
;	COMDAT ??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ PROC NEAR ; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAXV?$allocator@PAX@std@@@std@@IAEXXZ ; std::vector<void *,std::allocator<void *> >::_Tidy

; 389  : 		}

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5b		 pop	 ebx
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$vector@PAXV?$allocator@PAX@std@@@std@@QAE@XZ ENDP	; std::vector<void *,std::allocator<void *> >::~vector<void *,std::allocator<void *> >
_TEXT	ENDS
PUBLIC	?client@@3PAVRPCClient@@A			; client
PUBLIC	?open_handles@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A ; open_handles
_BSS	SEGMENT
?client@@3PAVRPCClient@@A DD 01H DUP (?)		; client
?open_handles@@3V?$vector@PAXV?$allocator@PAX@std@@@std@@A DB 010H DUP (?) ; open_handles
_BSS	ENDS
END
